<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:503px;" class="column-headers-background">A</th><th id="0C1" style="width:664px;" class="column-headers-background">B</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" dir="ltr"> </td><td class="s0" dir="ltr">Ցանկացած OS հնարավորություն ունի վիրտուալ հի՛շողության հետ աշխատելու, բայց <br>որպեսզի CPU-ն կարողանա ապահովել այդ աշխատանքը, անհրաժեշտ է MMU <br>/memory management unit, CPU-ի մեջ/ սարքը: Վիրտուալ հշողության գաղափարը ապահովում են <br>HDD/SSD-ի հաշվին։ OS-ը ցանկացած ծրագրի համար HDD/SSD-ի մեջ տալիս է վիրտուալ <br>հիշողության տեսքը։ Վիրտուալ հիշողությունը թույլ է տալիս փոքր հիշողության սարքի <br>դեպքում /RAM/, կարողանանք շատ մեծ ծրագրեր աշխատեցնել։ Ծրագրի ամբողջ <br>պարունակությունը չի բերվում RAM, այդ պահին հիշողության որ կտորը պետք լինի,<br>դա կտեղադրվի RAM-ում։<br><br>Քանի որ HDD/SSD դանդաղ աշխատող սարքեր են, միանգամից RAM է տեղափոխվում <br>512 byte չափով հիշողություն, սա HDD/SSD-ից RAM տեղափողվող Ֆիզիկական բլոկի չափն է։ <br>Ստանդարտիզացում կազմակերպելու համար OS-ը քննարկում է page-ի գաղափար։ <br>Page-ը բայթերի հաջորդականություն է, հիմնականում 4096 byte է։ Ինֆորմացիան <br>տեղափոխվում է page-ի չափով։ HDD/SSD-ի մեջ քննարկվող page-երը կոչվում են virtual page-եր։ <br>Virtual page-երի հետ ճիշտ աշխատելու համար RAM-ում առանձնացնում են համապատասխան <br>չափով physical page-եր։ Իմանալով RAM-ի չափը, կարող ենք իմանալ քանի page կարող է <br>տեղավորվել, օրինակ՝ 8gb RAM = 2^33 byte, page-ի չափը 2^12 byte է, այսինքն 2^21 page <br>կտեղավորվի։<br><br>Արտապատկերումը ճիշտ կազմակերպելու համար ծրագիրը ակտիվացնելիս loader-ը <br>ստեղծում է physical page table: Virtual page-երի մեջ քննարկվող հասցերին անվանում են <br>virtal address-ներ։ RAM-ի մեջ քոփի արվելուց հետո, արդեն CPU-ն կարող է աշխատել physical <br>address-ներով։ Դա այն հասցեն է, որը հատկացվում է պրոցեսին /ակտիվ ծրագիր/։<br><br>Compiler-ը , linker-ը աշխատում են վիրտուալ հասցեների հետ։ Երբ ծրագիրը տրամադրում <br>ենք CPU-ին, CPU-ն էլ է աշխատելու վիրտուալ հասցեների հետ, վիրտուալ հասցելով է <br>oprand read անելու, result store անելու։ HDD/SSD-ի հասցեները RAM-ի մեջ հասցեները ճիշտ <br>գեներացվելու համար պատասխանատու է MMU-ն։ Երբ CU-ն ուղարկում է վիրտուալ <br>հասցեն, սկզբում հասցեն գնում է MMU, MMU-ն կատարում է վիրտուալ հասցեի <br>թարգմանություն ֆիզիկական հասցեի։ Քանի դեռ virtual page-ը չի արտապատկերվել <br>RAM-ում, MMU-ն չի կարող կատարել թարգմանություն։ Հենց արտապատկերումը կատարվի, <br>MMU-ն կգեներացնի ֆիզիկական հասցե և դրանով կդիմի կամ RAM-Ին կամ cache-երին։<br><br>mmap ֆունկցիային կարող ենք փոխանցել միայն page-ի պատիկ չափեր։<br><br>PPT- physical page table - Քննարկվելու է ցանկացած պրոցեսի համար։ Գտնվում է RAM-ում, <br>իրենից ներկայացնում է սպեցիֆիկ էլեմենտների զանգված։ PPT-ի ամեն մի էլեմենտին <br>անվանում են PTE` page table entry: Պարզագույն PTE-ն բաղկացած է 2 դաշտից՝ <br>1․validation bit /1bit/, 2.page-ի հասցե պարունակող տարածք /չափը կախված է պլատֆորմից/։ <br>2-ի մեջ գրված է լինելու կամ վիրտուալ, կամ ֆիզիկական հասցե, կամ էլ NULL, <br>NULL-ը կնշանակի որ ոչ վիրտուալ page կա, ոչ ֆիզիկական, օրինակ .bss սեկցիայի դեպքում։ <br>Եթե գրված է physical page-ի հասցե, նշանակում է արդեն տեղի է ունեցել քեշավորում՝ <br>տվյալ page-ը գտնվում է RAM-ում։ Եթե virtal page-ի հասցե է գրված, նշանակում է տվյալ <br>page-ը դեռ գտնվում է HDD/SSD-ում։1-ի մեջ եթե 0 է՝ արտապատկերումը տեղի չի ունեցել, <br>եթե 1 է՝ արդեն արտապատկերումը տեղի է ունեցել։<br><br>Վիրտուլ հասցեի չափը կախված է պլատֆորմի բիթայնությունից, 32բիթ կամ 64բիթ, 64 բիթի <br>դեպքում օգտագործվում է միայն 48-ը։ Վիրտուալ հասցեի կրտսեր 12 բիթի միջոցով որոշվում <br>է page-ի մեջ որ հասցեին ենք դիմում։ Ավագ 20 բիթի /32 բիթի դեպքում, 48-ի դեպքում՝ 36 կլինի<br>/ միջոցով page-ի հասցեն է որոշվում,  որին անվանում են նաև page number: Կախված նրանից <br>page- ֆիզիկական է, թե վիրտուալ, կարող ենք տարբերել physical page number, virtual page number:</td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s0" dir="ltr"></td><td class="s0" dir="ltr">physical page-երի դեպքում հասցեի չափը կախված է RAM-ի հիշողության չափից։ <br>32 բիթի դեպքում 2^32 / 2^12 = 2^20, 64 բիթի դեպքում 2^33 / 2^12 = 2^21։<br>Եթե RAM-ը լցվի, և անհրաժեշտություն առաջանա նոր page բերելու, ամենաքիչ օգտագործվող<br>ֆիզիկական page-ը swap կարվի virtual page-ի հետ, տեղադրում է swaping space-ում։<br>Հաճախակի swap-երի պատճառով աշխատանքի արագությունը կրճատվում է։<br>OS-ը քննարկում է dirty page-ի գաղափար, եթե արժեքը 1 է, նշանակում է փոփոխման է <br>ենթարկվել, եթե 0 է, չի փոփոխվել։ Ոչ  dirty page-ը swap-ի չի ենթարկվում, որովհետև սկզբնական <br>տեսքը HDD/SSD-ում արդեն կա։ Code segment-ի դեպքում dirty bit-ը  է, եթե փոփոխություն լինի,<br>ոչ թե swap  կարվի, այլ կփոխվի ուղղակի։<br>Ծրագիրը RAM-ի մեջ կարող է հաջորդող physical page-երի տեսք չունենալ, virtual page-երը <br>հաջորդաբար են դասավորվում։<br>Երբ ծրագիր ենք թարգմանում, բուն executable  կամ shared ֆայլերի համար գեներացվում են<br> հստակ վիրտուալ հասցեներ։ Relocatable ֆայլերը վիրտուալ հասացե չունեն։<br><br>Loader-ը ցանկացած ծրագրի համար ստեղծում է PPT, որը կարող ենք դիտարկել որպես<br>սովորական զանգված։ virtual page number-ն իրենից ներկայացնում է PPT-ի ինդեքս։<br>Ինդեքսով դիմելու ենք կոնկրետ էլեմենտ ստանու համար, որի մեջ գրված է լինելու կամ <br>physical page address, կամ virtual page address: VPA֊ն և PPA-ն 2-ական կոդեր են, որոնք <br>տարբերելու համար է օգտագործվում validation bit-ը։ <br><br>Քանի որ CPU-ն աշխատանքը քննարկում է վիրտուալ հասցեներով, CPU-ի կողմից միշտ<br>ուղարկվելու է 32 բիթանոց կամ 48 բիթանոց վիրտուալ հասցեներ։ <br>Երբ CPU-ն CU-ի միջոցով ուղարկում է ինչ որ վիրտուալ հասցե, MMU-ն սկզբում կատարում է<br>հարցում ,VPN-ով դիմելու է RAM֊ին, ինչ էլեմենտ ստանում է, դրա միջոցով էլ հասականում է<br>որն է լինելու կոնկրետ ֆիզիկական հասցեն, այսինքն մինչև CPU-ի բուն հարցումը կատարելը<br>VPN են ուղարկում RAM, VPN֊ի պարունակությունը արտահայտող կտորը ուղարկում է RAM,<br>PPT-ի մեջ կոնկրետ ինդեքսով կդիմի հիշողությանը, տվյալ համարի PTE-ն հետ կուղարկեն CPU,<br>MMU-ն կքննարկի ստացած PTE-ն։ Եթե վալիդության բիթը 0 լինի, կառաջանա հատուկ դեպք՝<br>page foult, ազդանշան է ուղարկում OS-ին և OS-ը հատկացնում է նոր ֆիզիկական page: Եթե NULL<br>լինի ֆիզիկական ազատ page է հատկացվելու, 0-ից տարբերվող արժեք տեսնելու դեպքում <br>դիմելու են HDD-ին։ OS-ը իր մոտի table-ի միջոցով հասկանալու է որ physical page-ն է այդ պահին<br>ազատ կամ դեակտիվ վիճակում գտնվում, 0 քեշավորման բիթ ունեցողները կդիտարակվեն, 1<br>ունեցողները ոչ, քանի դեռ RAM-ում ազատ page-երի տարածք կա։ NULL-ի փոխարեն կգրվի <br>ուղարկված physical page-ի հասցեն, validation bit-ը կփոխի 1։ MMU-ն ստանում է PPA-ն,  կստանա<br>առաջին PTE-ն և կսկսի վիրտուալ page-ից ֆիզիկականի թարգմանությունը։<br>Ֆիզիկական քեշերը նույնպես կարող են իրենց մեջ PTE պարունակել։ Կարող է այդ պահին table-ները<br>քեշավորած լինել իր մեջ, բուն page-երը ոչ։ Այսինքն MMU-ն կդիմի քեշին, կստանա ֆիզիկական հասցե,<br>բայց page ստանալու համար կդիմի ռամին։ TLB-ն MMU-ի քեշն է /translation lookside buffer/։ <br>Shared-ի դեպքում նույն page-ի հետ կարող են աշխատել մի քանի ծրագրեր։ Core-երի աշխատանքը <br>սինխրոնիզացնելը կապ ունի քեշերի հետ, դրա համար գոյություն ունի հատուկ պրոտոկոլ, MESI <br>պրոտոկոլ /modifie exclusive shared invalid/։ Պրոտոկոլից ելնելով քեշի ինֆորմացիայի դիմաց <br>4 modifier-ներն են նշվում։ Phisycal page table-ը թույլ է տալիս հասկանալ HDD- և RAM-ի կապը՝ <br>HDD-ի մեջ գտնվող որ page-երն են արդեն RAM-ի մեջ։ TLB-ի հետ աշխատում է միայն MMU-ն, <br>իր մեջ պահում է PTE-ներ։ Վիրտուալ հիշողությունը թույլ է տալիս ծրագրի հիշողությունը <br>ավելի ապահով կազմակերպել։<br>Վիրտուալ հիշողությունը քննարկվում է մակարդակներով։ Օրինակ VPN-ը քննարկվում է մակարդակով՝<br>VPN L1, VPN L2...: MMU-ն գնում է PTD-ի վրա՝ page table directory, այն իր մեջ պարունակում է phisycal <br>page table-ների հասցեներ։ Այստեղ ևս կա վալիդության գաղափարը, page table-ը վալիդ է թե ոչ։<br> </td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s0" dir="ltr"></td><td class="s0" dir="ltr">PTBR - OS-ի կողմից ծրագրավորման ենթարկվող ռեգիստր։ Երբ MMU-ն VPN-ով դիմում է PPT-ին, <br>ու ավելի կոնկրետ հասցեով գնալու համար օգտագործում է PTBR ռեգիստրը։<br><br>mm-struct - հանդիսանում է պրոցեսի համար կարևոր տվյալ heap-ում, վերահսկվում է <br>OS-ի կողմից։ Սրա միջոցով է OS-ը քննարկում վիրտուալ հիշողության տեսքը։<br><br>Դինամիկ հիշողության հետ աշխատանքը կազմակերպվում է brk ֆունկցիայի միջոցով։<br>brk-ն ցույց է տալիս դինամիկ հիշողության վերջը։<br><br>garbage collectory- ը կատարում է վերադասավորում։<br><br>mmap-ը թույլ է տալիս ֆայլի մեջ ստեղծել նոր ֆայլ, կամ արդեն գոյություն ունեցող ֆայլի համար<br>հիշողություն հատկացնել։ mmap-ի միջոցով ստեղծված ֆայլերի հիշողությունը ծրագրի ավարտից <br>հետո մաքրվում է առանց մեր միջամտության։<br><br>typedef unsigned long size_t;<br><br>allocation `<br><br>void* malloc(size_t byte_count); //malloc - memory allocation<br>կանչում է brk ֆունկցիան, հիշողություն տրամադրելուց հետո հետ է վերադարձնում <br>հիշողության առաջին բայթի հասցեն։ Հասցեի հետ աշխատելու համար անհրաժեշտ է cast անել։<br><br>void* calloc(size_t byte_count, size_t times); //calloc - contiguous allocatin<br>Զանգվածի դեպքում ավելի նախընտրելի է։ Հիշողությունը արժեքավորում է 0-ներով։ <br><br>void* realloc(void *old_ptr, size_t new_size); realloc - resize allocation<br>pt = (int*)realloc(pt, 200);<br><br>exit(0) = mov rax, 60<br>              mov rdi, 0<br><br>ERRNO -  հատուկ գլոբալ փոփոխական, սրա մեջ պահվում է error-ի պատճառ հանդիսացող թիվը։<br><br>deallocation`<br><br>void* free(void* ptr);</td></tr></tbody></table></div>