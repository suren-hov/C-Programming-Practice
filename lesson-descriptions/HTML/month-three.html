<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{background-color:#ffffff;text-align:right;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s1{background-color:#fff2cc;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:503px;" class="column-headers-background">A</th><th id="0C1" style="width:664px;" class="column-headers-background">B</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0">array</td><td class="s0" dir="ltr">Նույնատիպ էլեմենտների հաջորդականություն։<br>ատարկություն, տարածք չի <br>զբաղեցնում։<br>sizeof(void) == 0;<br>Ապահասցեավորման համար կան 3 օպերատորներ՝ *, [ ], --&gt;<br>volatile<br><br>const int lenght = 100;<br>int arr[length];<br><br>equ = define<br>typeid - C++ ում զանգվածի տիպը ցույց տվող օպերատոր<br><br>Զանգվածները լինում են միաչափ և բազմաչափ։<br> </td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s0" dir="ltr">Functions</td><td class="s0" dir="ltr">Գործողությունների հաջորդականություն, որը ցանկացած պահի կարող ենք կանչել։<br><br>Fwunction signature` return value type, {function name}, (parameter list)<br><br>variatic functions, printf<br>Վարիատիկ ֆունկցիաներին կարող ենք ցանկացած քանակությամբ պարամետրեր <br>փոխանցել։<br><br>struct-ով կառելի է ստեղծել սեփական data type, կամ union-ով<br> </td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s0" dir="ltr">pointer</td><td class="s0" dir="ltr">ցույց է տալիս memory location֊ը։<br>Ցուցիչի զբաղեցրած հիշողությունը կախված է պլատֆորմի բիթայնությունից՝<br>4 բայթ կամ 8 բայթ, անկախ տիպից։<br>dereferencing - ապահասցեավորում<br><br>dangling pointer - ցուցիչ որը ինչ որ տեղ հղվում է, բայց այդ հասցեի փոփոխականը <br>փաստացի գոյություն չունի։<br> </td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s0" dir="ltr">  5     int x = 14;<br>  6 <br>  7     int* a = &amp;x;<br>  8 <br> 11     printf(&quot;%p\n&quot;, &amp;x);<br> 12     printf(&quot;%p\n&quot;, a);<br> 13 <br> 14     printf(&quot;%d\n&quot;, x);<br> 15     printf(&quot;%d\n&quot;, *a);</td><td class="s0" dir="ltr">x-ին վերագրում է 14<br><br>a անունով int տիպի pointer-ին վերագրում է x-ի հասցեն<br><br><br>տպում է x-ի հասցեն և a pointer-ը<br><br>տպում է x-ի արժեքը և ապահասցեավրած a-ի առժեքը։<br><br>եթե *a-ին վերագրենք այլ թիվ, x- արժեքը կփոխվի։<br><br>եթե գրենք int num = ox34, կտպի 16-ական թվի 10-ական տեսքը՝ 52<br> Լ</td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s0" dir="ltr">little endian</td><td class="s0" dir="ltr">Երբ առաջին բայթը գտնվում է ներքևի հասցեում, աջից ձախ<br> </td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s0" dir="ltr">bid endian</td><td class="s1" dir="ltr">Երբ առաջին բայթը գտնվում է վերևի հասցեում,<span style="text-decoration:line-through;"> ձախից աջ</span><br> </td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s0" dir="ltr">1 #include &lt;stdio.h&gt;<br>  2 <br>  3 int main() {<br>  4 <br>  5     int num = 0;<br>  6     printf(&quot;%d\n&quot;, num);<br>  7 <br>  8 <br>  9     char* p = (char*)&amp;num;<br> 10     *(p + 2) = 12;<br> 11     printf(&quot;%d\n&quot;, num);<br> 12 <br> 13 return 0;<br> 14 }<br>~       </td><td class="s1" dir="ltr">p ցուցիչին, որը հղվում է char տիպի փոփոխականի չափով, վերագրում ենք<br>num-ի հասցեի առաջին բայթը, դա նշելով (char*)&amp;num static cast-ով(convert)։<br><br>հետո ապահասցեավորած *(p+2)-ին վերագրում ենք 12, դա նշանակում է, որ<br>3-րդ բայթի մեջ գրվելու է մեր նշած թիվը</td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s0" dir="ltr">undefined behavior</td><td class="s0" dir="ltr">չսահմանված պահվածք ծրագրի կողմից<br> </td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s0" dir="ltr">segmentation fault</td><td class="s0" dir="ltr">ստանում ենք, երբ դիմում ենք մեզ  չհատկացված կամ գոյություն <br>չունեցող հասցեի։<br> </td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s0" dir="ltr">void* pointer</td><td class="s0" dir="ltr">կարող է հղվել ցանկացած փոփոխականի վրա, կամ արժեքավորվել <br>ցանկացած ցուցիչից։<br> </td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s0" dir="ltr">int* p1 = &amp;y;<br>int* p2 = p1;<br> </td><td class="s0" dir="ltr">p1 և p2 ցուցիչները պահում են y-ի առաջին բայթի հասցեն</td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s0" dir="ltr">NULL</td><td class="s0" dir="ltr">Implementation defined<br>int* p = NULL; այս դեպքում կասենք, որ ցուցիչը հղված չէ որևէ հասցեի, և <br>աշխատեցնելիս ոչ թե սխալ՝ աղբով կաշխատի, այլ կառաջանա runtime error:<br> </td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s0" dir="ltr">const</td><td class="s0" dir="ltr">const տիպի փոփոխականը պետք է լինի սկզբնարժեքավորված, հակառակ դեպքում<br>արժեքավորված կլինի աղբով, որը չենք կարող փոխել։<br> </td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s0"></td><td class="s0" dir="ltr">define -,ի դեպքում փոփոխման ենթակա փոփոխականը գրել մեծատառերով, օր՝ SIZE<br> </td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s0"></td><td class="s2" dir="ltr">4</td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s0"></td><td class="s0" dir="ltr">arr[2] == *(arr + 2) == *(2 + arr) == 2[arr]</td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s0" dir="ltr">functons</td><td class="s0" dir="ltr">խմբավորված ինսրուկցիաներ, որոնք ունեն ինչ որ անուն, որի միջոցով կարող ենք <br>կանչել ֆունկցիան և կատարել ֆունկցիայի պարունակությունը։ Թույլ է տալիս <br>խուսափել կրկնվող կոդի կտորներից։<br><br>void֊ի դեպքում կարելի է գրել return;<br><br>function prototype - int f(double, double);<br>function signature - int f(double x, double y);<br><br>&lt;stdio.h&gt; - ում մի քանի ֆունկցիաների նախատիպեր են<br>&lt;stdbool&gt; -ի միջոցով կարող ենք ստանալ true or false արդյունք, այսինքն եթե <br>արտահայտությունը ճիշտ է, կտպի true`1,  եթե սխալ է, կտպի false` 0:<br><br>Ֆունկցիան, որը կանչում է ինքն իրեն, և ունի դադարի պայման, կոչվում է ռեկուրսիվ։<br><br>եթե arr-ը պետք է return անենք, ֆունկցիան պետք ՝է լինի int * տիպի<br> </td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s0" dir="ltr">strings</td><td class="s0" dir="ltr">let str = &quot;kvbkbk&quot;; //js<br>str += &quot;456&quot;   //concatenate<br><br>std::string s = &quot;dfdfhgdh&quot;;   //c++<br>s += &quot;456&quot;;<br><br>strlen() string lenght հաշվող ֆունկցիա<br>strcopy() string copy անող ֆունկցիա<br><br>sppreferance karox enq gtnel<br> </td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s0" dir="ltr">Pointers</td><td class="s0" dir="ltr">Pointer-ը հասցե պահող էություն է։ Data type է, որի միջոցով ստեղծված <br>փոփոխականները իրենց մեջ կարող են պահել մեկ այլ փոփոխականի կամ զանգվածի,<br>ֆունկցիայի հասցե։ Կարող է լինել ցանկացած տիպի։ Pointer-ի տիպը նշելու միջոցով <br>կարող ենք իմանալ ինչ չափի հիշողություն ենք դիտարկելու, ինչ տիպի <br>պարունակություն է ունենալու։<br><br>void pointer֊ի միջոցով կարող ենք դիտարկել միայն հասցե, հիշողությունը չենք կարող <br>դիտարկել, void-ի մջոցով հասցեի արժեքին չենք կարող հղվել։<br><br>Ցուցիչի չափը կախված է պլատֆորմի բիթայնությունից, 32bit - 4 byte, 64bit - 8 byte:<br><br><span style="color:#ffd966;">float, double, long double տիպի թիվը չենք կարող % մնացորդով բաժանել։</span><br><br>Pointer-ների հետ կիրառվող օպերատորներ՝<br><br>* - dereference operator /unar/,<br>[ ] - subscript operator,<br>-&gt; - կիրառվելու է մեր սեփական data type-երի հետ,<br>&amp; - reference operator /unar/,<br>arithmetic operators` առանց *, /, %,<br>logic operators,<br>cast,<br>sizeof:<br><br>Անիմաստ հղումներից խուսափելու համար pointer-ին կարող ենք վերագրել NULL:<br><br>int a;<br>int *ptr = &amp;a;       // lea qword [rbp - 12], [rbp - 4] , 2-րդ օպերանդի հասցեով չեն դիմում ռամին,<br>հաշվարկում են, տեղադրում են առաջին օպերանդի տեղում։<br>scanf(&quot;%d&quot;, &amp;n) = scanf(&quot;%d&quot;, ptr)      // mov rdi, format<br>                                                               mov rsi, [rbp - 12]<br>                                                               call scanf<br><br>sizeof(*ptr) = sizeof(a);<br>*ptr-ն միշտ իրեն  պահելու է a-ի պես։<br><br><br>void something(int *arg) {   //ոչ թե copy կանի stack-ի մեջ պահելու համար, այլ նույն<br>*arg == 10;                           հիշողության վրա հղվելով կփոխի արժեքը։<br>*arg --;<br>}<br><br><br>Little, big endian ստուգելու համար՝<br><br>int main() {<br>int a = 1;<br>char* ptr = (char*) &amp;a;<br>if(*ptr == 0) {<br>printf(&quot;Big endian&quot;);<br>}<br>else{<br>printf(&quot;Little endian&quot;);<br>}<br><br><br><br>T*[int] = *(T* + int);<br><br><br>cast-ի օրինակով խնդիր՝<br><br>int a;<br>char *pt1 = (char*) &amp;a;<br>short *pt2 =(short*) (pt1 + 2);<br>pt1[0] = 10;<br>pt1 ++;<br>*(pt1 +2) = 20;<br>pt2[-1] = 96;<br>1[pt1] = 50;   // *{1+pt1)<br>[pt2] = 80;     //0[pt2]<br><br>pt1 = (char*) &amp;pt2;   //լավ չի, բայց կաշխատի<br>printf(&quot;%d&quot;, (char*)pt2) - pt1);   //նույն տիպի ցուցիչներ են, կտպի (char*)pt2 -ից pt1֊ի միջև չափը։<br><br>int a = 20;<br>int * ptr = &amp;a;<br>int ** pptr = &amp;ptr;<br>int *** ppptr = &amp;pptr;      //int տիպի արժեքին հասցնելու համար պետք է 3  անգամ <br>ապահասցեավրել ppptr pointer-ը։<br><br>const int a,b,c;    //3 հատ error<br>int const a,b,c;    //1 հատ error, միայն  a-n<br><br>const int * ptr, ptr1;     //poiinter, որը դիտարկելու է const ձևով հիշողությանը, ptr1֊ը cont int է, pointer չի։<br>ptr = &amp;a;                     //ճիշտ է<br>*ptr = 5;                      //սխալ է<br><br>int const *ptr2; == վերևի օրինակին<br>int *const ptr3;  //առանց սկզբնարժեքավորելու error կտա<br>ptr3 = &amp;b;         //error<br>ptr3 = 60;         //կաշխատի<br><br>const int *const ptr - ամենա-const դեպքը, անիմաստ է, ոչ մի բան չենք կարող անել </td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s0" dir="ltr">Function pointer</td><td class="s0" dir="ltr">double add(int, int);    //function signature<br>double sub(int, int);<br>double (*fptr)(int, int); //function pointer<br>fptr = add;                  //հղվել add ֆունկցիայի վրա<br>fptr = sub;<br><br><br>typedef static unsigned const int chlp;<br>static unsigned const int անդուր երկար գրելու փոխարեն կարող ենք գրել ուղղակի chlp:<br><br>typedef int(*operation)(int, int);   <br>operation o_arr[4];         //operation-ի միջոցով ստեղծում ենք function pointer<br>օ_arr[0] = mul;<br>o_arr[1] = add;<br>o_arr[2] = div;<br>o_arr[3] = sub;<br>o_arr[i](a, b);<br><br>int add(int, int);<br>int sub(int, int);<br>int mul(int, int);<br>int div(int, int);<br><br><br><br>int foo(int *arr; int size; int(*cond)(int)) {<br>for(int i = 0; i &lt; size; i++) {<br>if(cond(arr[i] {<br>return arr[i];<br>}<br>return -1;<br>}<br><br>int is_odd(int a) { return a % 2 != 0;}<br>int is_even(int a) { return a % 2 = 0;}<br>...<br><br>foo(arr, 10, is_odd);<br>foo(arr, 10, is_even); <br> </td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s0" dir="ltr">strings</td><td class="s0" dir="ltr">string - տերմին, որով դիմում են char-երի զանգվածին։ <br>Char-երի զանգվածի վերջում միշտ կա &#39;\0&#39;:<br>sizeof(&#39;a&#39;) != sizeof(&quot;a&quot;) - քանի ոը &#39;a&#39;-ն ուղղակի սիմվոլ է, զանգված չէ, &quot;a&quot;-ն զանգված է, որի <br>վերջում կա \0: Այս երկուսի տիպերն էլ են տարբեր։ &#39;a&#39;-ն char տիպի է,  &quot;a&quot; - ն const char* տիպի։<br><br>char str[10] = &quot;Hello&quot;;      //o-տառից հետո կլինի \0, հաջորդ բայթերի մեջ կլինի garbage<br>char str[10] = {&quot;Hello&quot;};    //o-տառին հաջորդող բոլոր ազատ բայթերի մեջ կլինեն \0-ներ։<br>str[5] = &#39;w&#39;;                       //\0֊ն կկորցնենք, և %s-ով տպելով չի իմանա մինչև որտեղ պետք է տպի։<br><br>size_t = unsigned long, հայտարարված է typedef-ով։<br>typedef undigned long size_t;<br><br><br>int strlen(const char* str) {<br>int count = 0;<br>while(*str != &#39;\0&#39;) {<br>count ++;<br>str++;<br>}<br>return count;<br>}<br><br><br><br>int r_strlen(const char *str) {<br>if(*str == &#39;\0&#39;) {<br>return 0;<br>}<br>return r_strlen(str + 1) + 1;<br>}<br><br><br>const char *strcpy(char *dest_str, const char *src_str) {<br>int i = 0;<br>while(*src_str != &#39;\0&#39;) {<br>dest_str[i] = *src_str;<br>i++;<br>src_str ++;<br>}<br>return dest_str;<br>}</td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s0" dir="ltr">ELF Files /executable and linkable file format/<br>1.relocatable<br>2.shared<br>3.executale</td><td class="s0" dir="ltr">Սեկցիաներ, որոնք միշտ քննարկվելու են՝<br>.data<br>.bss<br>.rodata<br>.text <br><br>Linker֊ի կողմից քննարկվող սեկցիաներ՝ <br>.symtab<br>.rel.text<br>.rel.data<br>Linker-ի աշխատանքից հետո այս սեկցիաները կարող են վերանալ, հիմնականում չեն <br>վերանում shared object file-ի առկայության դեպքում։ <br><br>․symtab-ի մեջ compiler-ը ավելացնում է օգտագործած սիմվոլները՝ գլոբալ  փոփոխականների, <br>ֆունկցիաների անունները և հիշողության չափը, վայրը։ Լոկալ տիրույթում հայտարարված <br>փոփոխականների մասին ինֆորմացիա չի պահվում .symtab-ում։  Եթե կապակցումից հետ<br>մնա այս սեկացիայում առկա որևէ փոփոխական կամ ֆունկցիա, որին linker-ը չգտնի,<br>linker error կտա։<br><br>․rel.text և .rel.data սեկցիաների միջոցով լինկերը հասկանում է տվյալ սիմվոլներին որտեղ <br>պետք է վերադասավորի։<br>․rel.text սեկցիան նախատեսված է այլ կապակցման ենթակա օբյեկտների՝ ֆունկցիաների <br>ճիշտ վերադասավորման համար։<br>․rel.data սեկցիան արտահայտում է .data .bss սեկցիաներում վերադասավորման միտքը,<br>այլ ֆայլերի մեջ գտնվող տվյալներին կապակցելու համար է։<br><br>Այլ ֆայլից փոփոխական կամ ֆունկցիա ստանալու միտքը արտահայտում ենք extern <br>keyword-ով։ Հանդիսանում է storage class: Extern֊ով նշված էությունը հանդիսանում է գլոբալ, <br>և ծրագրի սկզբից մինչև վերջ մնալու է ram-ում։<br><br>Կարող են առաջանալ սեկցիաներ, որոնք պետք են debuger-ին`<br>.debug<br>.line<br>.strtab<br>գեներացվում են gcc -g option-ը կիրառելիս։<br>․symtab-ի մեջից անվանումները բերում պահվում են այստեղ, որպեսզի կարողանանք<br>breakpoint-եր կամ watchpoint-եր սահմանել։ Այստեղ արտահայտվում է, թե որ տողում է <br>կատարվել ֆունկցիայի կանչը, տվյալի օգտագործումը /.line/ ։ Breakpoint սահմանվում է <br>ֆունկցիայի անվան կամ label-ի վրա, watchpoint֊ ը սահմանվում է փոփոխականի անվան <br>վրա /.strtab/։ .debug-ի մեջ պահվում է այս երկուսի մասին ինֆորմացիա։<br>-g option-ը նշելիս linking-ից հետո .symtab, .strtab, .debug, .line սեկցիաները չեն վերանա։<br><br>Linker-ի կողմից կապակցումը տեղի է ունենում 2 եղանակով՝ static, dynamic:<br>shared object file-երը ենթարկվում են dynamic կապակցման, relocatable-ը՝ static:<br>Shared-ի դեպքում կապակցումը տեղի է ունենում ոչ թե linking-ի ժամանակ, այլ runtime:<br><br>Header ֆայլը և գրադարանային ֆայլը տարբեր բաներ են։ Header ֆայլերի մեջ հիմնականում <br>գրվում են ֆունկցիաների նախատիպերեը և հայտարարվում են գլոբալ փոփոխականներ։<br>Գրադարանային ֆայլերը գտնվում են root-ի պատասխանատվության տակ գտնվող <br>ինչ որ դիրեկտորիայի մեջ։ Ամեն ֆունկցիա ունի իր առանձին օբյեկտային ֆայլը,  <br>որը relocatale տիպի է։ Արխիվային ֆայլ է հանդիսանում մեր գրադարանային <br>հիմնական ֆայլը, որի մեջ concate են արվում մեր նշված օբյեկտային ֆայլերը։ <br>Բոլոր սեկցիաները իրար հետ concat են լինւմ։ Ունեն .a ընդլայնումը։<br><br>Օպերացիոն համակարգի համար նախատեսված սեկցիաներ՝<br>ELF header section,<br>section header table:<br>ELF header section-ը իր մեջ պարունակում է ֆայլի վերաբերյալ մետաինֆորմացիա։ Սրա <br>միջոցով OS-ը հասկանանոլւ է ինչ բնույթի ֆայլ է /relocatable, shared, executable/, <br>ինչ գործողություն պետք է անի, կամ թե ով է սրա հետ աշխատելու, զբաղեցրած <br>հիշողության մասին ինֆորմացիա, ինչ ֆայլերի հետ կապ ունի։ <br>section header table-ի մեջ հիմնականում արտահայտվում է ինֆորմացիա executable ֆայլի<br>սեկցիաների չափերի մասին, ըստ որի ծրագիրը ակտիվացնելիս արագ արագ<br>սեկցիաները պատճենել ռամի մեջ։ Սրա միջոցով է ձևավորվում  նաև ծրագրի <br>վիրտուալ հիշողության տեսքը։<br><br>executable ֆայլի մեջ ամեն ինչ 0 1֊երի տեսք ունի։</td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s0" dir="ltr">storage classes</td><td class="s0" dir="ltr">compiler-ի ճիշտ աշխատանքի համար են նախատեսված։ Փոփոխականի դիմացից կարող ենք <br>նշել storage class-ը, ակնհայտ ցույց տալու համար։<br>C-ում քննարկվող storage class-երը 5֊ն են՝<br>auto<br>static<br>register<br>extern<br>thread_local  /c-ի -- թվականի թարմացումից հետո է ավելացվել։ ֆունկցիա է, որը<br>մեր ծրագրի աշխատանքին զուգահեռ կատարվելու է, տվյալ cpu-մեկ core-ը կարող է <br>կատարել միաժամանակ 2 thread:/<br><br>Ցանկացած լոկալ  փոփոխական ավտոմատ ստանում է auto storage class-ի միտք։<br>Նշանակում է, որ տվյալ էության կյանքի ցիկլի կազմակերպումը compiler-ը իր <br>կողմից է որոշում։ Auto storage class չենք կարող տալ գլոբալ փոփոխականի, կիրառում ենք<br>միայն լոկալ տիրույթում։ Օգտագործվել է մինչև C-99 ստանդարտը, դրանից հետո չի <br>կիրառվում։ <br><br>static - կարող ենք հայտարարել գլոբալ և ստատիկ փոփոխականների, ֆունկցիաների հետ։<br>Ազդում է linker-ի աշխատանքի վրա։ Տվյալ translation unit-ից կամ relocatable ֆայլից դուրս<br>չի կարող օգտագործվել /internal linkage/։ Ծրագրի սկզբից մինչև վերջ հիշողություն է <br>զբաղեցնելու։<br> <br>Կարող են թույլ տալ քեշավորում ապահովել` <br>int factorial(int n) {<br>static int arr[30];<br>if(arr[n] != 0) { return arr[n]; }<br>if(n == 0) { return arr[0] = 1; }<br>arr[n] = n * factorial(n-1);<br>return arr[n];<br>}<br><br>Կարող ենք ստանալ նաև ֆունկցիայի կանչերի քանակը՝<br>int foo( ... ) {<br>static int count = 0;<br>count ++;<br>.<br>.<br>.<br>return count;<br>}<br><br><br>Ցանկացած ֆայլ, որը տրամադրում ենք gcc-ին, ավտոմատ դառնում է translation unit, որի <br>հիման վրա հետագայում ստացվում է relocatable object file, հետո executable:<br><br>external linkage֊ի միտքը ցույց տալու համար հայտարաում ենք գլոբալ տիրույթում, <br>կամ նշում ենք extern keyword-ը։ extern կարող ենք օգտագործել նաև լոկալ տիրույթում, <br>դա կնշանակի, որ այլ ֆայլից կբերվի, բայց կօգտագործվի միայն տվյալ լոկալ տիրույթում։<br>Միայն declaration-ի համար է նախատեսված, definiton /արժեքավորում/ չենք կարող անել։<br>const փոփոխականի հետ պարտադիր պետք է նշել, հակառակ դեպքում չի հասկանա որ<br>այլ ֆայլից ենք բերում, կասի, որ const-ը արժեքավորված չէ։<br><br>register - հնեցված է, կիրառվում է լոկալ փոփոխականների հետ։ Compiler-ը տվյալ փոփոխականի<br>համար cpu-ում մեկ ռեգիստր է ռեզերվ անում։ Ապահովում է արագություն։</td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s0" dir="ltr">storage durations</td><td class="s0" dir="ltr">Վերաբերվում է միայն տվյալներին։<br><br>static storage duration-ով տվյալները ծրագրի սկզբից մինչև վերջ ապրելու են։<br>Static և extern keyword-երով կամ գլոբալ հայտարարված փոփոխականների դեպքում է <br>duration֊ը static:<br><br>automatic storage duration-ով տվյալները ապրում են ֆունկցիայի սկզբից մինչև ֆունկցիայի վերջ։<br>Auto և registr keyword-երով կամ լոկալ հայտարարված փոփոխականների դեպքում է<br>duration-ը automatic:<br><br>manual storage duration - ստանում է միայն դինամիկ հիշողությունը։ Մենք ենք որոշում<br>կյանքի տևողությունը՝ հիշողության հատկացումը և ազատումը։<br> </td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s0" dir="ltr">qualifiers</td><td class="s0" dir="ltr">Ազդում են միայն compiler-ի աշխատանքի վրա։<br><br>const - արժեքը թույլ չի տալիս փոխել։<br>volotile - փոփոխականի վրա օպտիմիզացիաներն է անջատում։ Կապված է thread-ների հետ։<br>atomic - ավելի շատ կախված է սարքային աշխատանքից։ Քանի դեռ atomic փոփոխականի հետ<br>ինստրուկցիաները չի ավարտել, հաջորդին չի անցնելու։ <br>restrict - compiler-ը հասկանում է , որ միայն մի pointer-ի միջոցով կարող է գտնել արժեքը։<br> </td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s0" dir="ltr">`</td><td class="s0" dir="ltr">Կատարում  է executable ֆայլերի սեկցիաների կապակցում, relocate-ի կազմակերպում։<br>Լinker-ը լուծում է 2 հիմնական խնդիր՝<br>link resolution<br>link relocation<br> <br>link resolution - Եթե մի relocatable object file-ի մեջ կան ինչ որ անուններ, որ այդտեղ չեն <br>գեներացված, պետք է գնա գտնի այլ ֆայլից, որի մեջ սահմանումը կա անունի և միացնի <br>executable ֆայլին։<br>link relocation - կապակցումից հետո նոր քննարկվող հասցեները ճիշտ տեղերում <br>օգտագործելու միտքն է կրում։<br><br>Որպեսզի linker-ը կարողանա գտնել անհրաժեշտ ֆունկցիայի կամ փոփոխականի <br>սահմանումը, .symtab սեկցիայի մեջ գեներացվում են ստրուկտուրաներ /struct/:<br>Struct-ի միջոցով ստեղծում ենք մեր սեփական data type-ը։<br><br>Symbol entry ստեղծվում է յուրահատուկ սիմվոլ տեսնելու դեպքում, միայն մեկ անգամ՝<br><br>typedef struct {<br>int name;             //index compiler-ի կողմից քննարկվող symbol table-ի վրա<br>char type: 4;        //առաջին 4 բիթերը char֊ի type անվանումը ունեն, type-ի մեջ պահվում է <br>                             փոփոխական է, թե ֆունկցիա<br>binding: 4;           //երկրորդ 4 բիթերը char֊ի binding անվանումը ունեն /bitfield-ի միտքն է char-ի <br>                             կեսը/։ Ցույց է տալիս ներքին կապակցման պետք է ենթարկվի, թե արտաքին։<br>char reserved;     //ռեզերվ արած հիշողություն է, որը չի օգտագործվում<br>short section;       //ցույց է տալիս որ սեկցիայում է արտահայտվում։ Կան pseudosection-ներ, <br>                              որոնք քննարկվում են relocatable և shared object ֆայլերի մեջ։<br>                              ABS, UNDEF, COMMON,<br>long offset;           //ցույց է տալիս սեկցիայի սկզբից քանի բայթ պետք է շեղվենք փոփոխականին <br>                              հասնելու համար։<br>long size;              //տվյալ էության չափը<br>} ELF 64_symbol_entry;   //symbol entry<br><br>Relocation entry ստեղծվում է տվյալ սիմվոլին դիմելու ցանկացած կետում։<br><br>typedef struct {<br>long offset;              //ինչ շեղման տակ է գտնվում, օրինակ call foo-ին դեմելու տեղը ցույց կտա<br>long type:32;           //տիպը՝ 8 բայթի առաջին կեսը<br>symbol.index:32;     //ինֆորմացիա է, թե որ սիմվոլին ենք ռեֆերենս անում՝ 8 բայթի 2-րդ կեսի մեջ<br>long addend;           //offset-ին գումարվող թիվ։<br>}ELF 64_Relocation_entry;<br><br>relocatable object file ստանալու համար gcc -c filename.c, main֊ի չլինելու դեպքում error չի տա;<br>shared object file֊ի համար՝ gcc -shared filename.c<br>executable` gcc main.c filename.h -l/my_archive<br><br>Արխիվային ֆայլը relocatable object ֆայլերի հավաքածու է։ Սեփական արխիվ սարքելու համար՝<br>ar rcs archivename.a objectfile1.o objectfile2.c ...<br><br>strong symbol - արժեքավորված սիմվոլներ<br>weak symbol - չարժեքավորված սիմվոլներ<br>strong symbol count &gt; 1         //error<br>1 strong symbol, many weak  //strong<br>many weak                              //undefined behavior<br><br>readelf - ծրագիր է, որը թույլ է տալիս մեր ուզած սեկցիայի պարունակությունը մարդուն <br>հասկանալի ձևով կարդանք։<br>objdump - ասեմբլեռական տեսքով թույլ է տալիս կարդալ ծրագիրը սեկցիաներով:<br><br>relocation types`<br>pc relative relocation<br>absoulte relocation</td></tr></tbody></table></div>