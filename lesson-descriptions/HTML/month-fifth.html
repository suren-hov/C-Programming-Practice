<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s2{border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s1{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s3{border-left:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:384px;" class="column-headers-background">A</th><th id="0C1" style="width:533px;" class="column-headers-background">B</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" dir="ltr">PCB - Process Control Block</td><td class="s0" dir="ltr">Որպեսզի պրոցեսի աշխատանքը օպերացիոն համակարգը կառողանա ճիշտ<br>կազմակերպել, ստեղծում է PCB: Struct է, բաղկացած 72 անդամ փոփոխականից։:<br><br>PCB-ի մեջ կան որոշ անդամ փոփոխականներ, որոնց հետ առնչվելու ենք`<br>unsigned long state;<br>list_head* parent;<br>list_head* child; <br>list_head* siblings;<br>int exit_code; <br>int exit_signal;<br>task_struct* r_parent; <br>task_struct* next_task;<br>task_struct* prev_task;<br>pid_t pid;<br>pid_t ppid;<br></td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s0" dir="ltr">Process States <br>/Նախատեսված են PCB-ի մեջի unsingned long state-ին <br>արժեքավորելու համար։/</td><td class="s0" dir="ltr">TASK_RUNABLE /execute or executable/<br>TASK_STOPPED /interrupt, SIGSTOP signal/<br>TASK_TRACED /interrupt, debuger-ի աշխատանքի ժամանակ է առաջանում/<br>TASK_INTERRUPTABLE /interrupt/<br>TASK_UNINTERRUPTABLE /interrupt/<br>EXIT_ZOMBIE /պրոցեսի ամբողջ ինֆորմացիան վերանում է, բացի PCB-ից և <br>kernel space-ից/ <br>EXIT_KILL /վերանում է նաև PCB-ն/<br> </td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s0" dir="ltr">Սկզբնական պրոցես - init</td><td class="s0"></td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s0" dir="ltr">Հեշավորում</td><td class="s0" dir="ltr">Իրենից ներկայացնում է որոշակի տվյալի միջոցով մեկ այլ արժեքի գտնելու միտքը։<br>Բաղկացած է 2 կոմպոնենտից՝<br>key - անունը<br>value - օբյեկտը</td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s0" dir="ltr">pid_t getpid();<br> </td><td class="s0" dir="ltr">returned process identifier</td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s0" dir="ltr">pid_t getgid();<br> </td><td class="s0" dir="ltr">returned gropu id</td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s0" dir="ltr">pid_t getppid();<br> </td><td class="s0" dir="ltr">returned parent process identifier</td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s0" dir="ltr">int execl(const char* pathname, const char* arg, ..., NULL);</td><td class="s0" dir="ltr">execl - execute list<br> </td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s0" dir="ltr">main-ին փոխանցվող արգումենտներ</td><td class="s0" dir="ltr">int main(int argc, char* argv[]);            //./a.out 1+1 file.txt<br>այս դեպքում արգումենտների քանակը 3 է՝ argc<br>դրանք main-ը ընդունում է char-երի զանգվածի տեսքով։<br> </td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s0" dir="ltr">int execv(const char* pathname, char* const argv[]);</td><td class="s0" dir="ltr">execv - execute vector, execl-ից տարբերվում է արգումենտներ փոխանցելու ձևով։<br> </td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s0" dir="ltr">int execle(const char* filename, const char* argv[], ..., <br>char* const envp[]);<br> </td><td class="s0" dir="ltr">execlp - execute live environment</td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s0" dir="ltr">int execve(const char* pathname, char* const arg[], <br>char* const envp[]);<br> </td><td class="s0" dir="ltr">execve - execute vector environment;</td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s0" dir="ltr">int execvp(const char* filename, chra* const envp[]);<br> </td><td class="s0" dir="ltr">execvp - execute vector path</td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s0" dir="ltr">int execlp(const char* filename, const char* args, ..., NULL);</td><td class="s0" dir="ltr">execlp - execute live path<br></td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s0" dir="ltr">pid_t fork();</td><td class="s0" dir="ltr">&gt; 0 - child process pid in parent process<br>= 0 - child process id in child process<br>-1   - fork failed<br> </td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s0" dir="ltr">int at_exit(void(*fptr)(void));</td><td class="s0" dir="ltr">Թույլ է տալիս կանչել ֆունկցիա ծրագրի return անելսւց հետո։<br>OS-ը փոխանցված ֆունկցիան տեղադրում է ստեկի մեջ, հակառակ <br>հաջորդականությամբ են կատարվելու, եթե մի քանի ֆունկցիա օգտագործենք;<br> </td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s0" dir="ltr">int on_exit(void(*fptr)(int, void*), void* arg_struct);</td><td class="s0" dir="ltr">Նախատեսված է ավելի բարդ կառուցվածքով ֆունկցիաների համար։<br> </td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s0" dir="ltr">pid_t wait(int* status);</td><td class="s0" dir="ltr">Առաջին հանդիպած child process-ին terminate 1 անում։ EXIT_KILL վիճակ է <br>տալիս։<br>Վերադարձնում է ավարտված child process-ի id-ն, կամ child չգտնելու դեպքում՝ -1։<br> </td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s0" dir="ltr">pid_t waitpid(pid_t pid, int* status, int opt);<br><br>Թույլ է տալիս քննարկել stopped, zombie, traced վիճակները։</td><td class="s0" dir="ltr">pid_t pid կարող է ստանալ 4տիպի արժեք՝<br>pid &lt; -1 - group<br>pid = -1 - any child process<br>pid = 0  - parent process-ի խմբում գտնվող child-ին է terminate անում։<br>pid &gt; 0  - specified pid<br> <br>opt - options`<br>WNOHANG -բլոկավորման մեջ չպետք է ընկնի process-ը<br>WUNTRACED - traced վիճակը չի քննարկում<br>WCONTINUED - stopped-ից runable վիճակի անցնող պրոցեսներն է քննարկում։<br><br>Կան մակրոսներ, որոնք միջոցով կարող ենք իմանալ ինչ վիճակում է process-ը՝<br>int WIFEXITED(status) - returned true or false, ճիշտ կլինի միայն exit_zombie<br>դեպքում։<br>int WIFSIGNALED(status) - true or false, ազդանշանի պատճառով է ավարտվել թե ոչ։<br>int WEXITSTATUS(status) - տալիս է return-ի արժեքը<br>int WTERMSIG(status) - returned termination signal number<br>int WIFCOREDUMP(status) - true or false<br>int WIFSTOPPED(status) - if process stopped returned true<br>int WIFCONTINUED(status) - true or false<br>int WSTOPSIG(status) - վերադարձնում  է ազդանշանի արժեքը։<br> </td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s0" dir="ltr">int setpgid(pid_t pid, pid_t pgid);</td><td class="s0" dir="ltr">Եթե pid = 1000, pgid-ն դնենք 0, կստեղծվի նոր խումը, որի owner-ը կլինի 1000 pid-ով<br>պրոցեսը և group id-ն կդառնա 1000։ Եթե fork-ի միջոցով նոր պրոցես ստեղծենք, դրա <br>pid-ն կլինի այլ թիվ, իսկ group id-n կլինի 1000։<br>Եթե pgid-ն դնենք 0-ից մեծ թիվ, տվյալ pid-ով պրոցեսի group-ը կդառնա այդ թվով group-ը։<br> </td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s0" dir="ltr">process scheduler</td><td></td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s0"></td><td class="s0" dir="ltr">Եթե OS-ը պետք է կատարի միաժամանակ մի քանի պրոցեսներ կամ thread-ներ, այն պարտադիր <br>պետք է ունենա process scheduler: Սրա նպատակն այն է, որ համակարգի բոլոր ռեսուրսները <br>կարողանա ճիշտ պահի ճիշտ պրոցեսի տրամադրի։ Պրոցեսների պլանավորումը քննարկվում է միայն<br>runable վիճակում գտնվող պրոցեսների համար։<br><br>Պրոցսին տրամադրվող ժամանակի հաշվարկը կատարվում է առաջնահերությունից ելնելով։<br>Պրոցեսների տեսակները՝<br>Real time process<br>Normal process<br><br>Քննարկվում են 3 տեսակի առաջնահերթություններ՝<br>Static priority /նախատեսված է նորմալ պրոցեսների համար։ Միջակայքը 0 կամ 100-139/<br>Normal priority /նախատեսված է նորմալ պրոցեսների համար, թույլ է տալիս OS-ին <br>տարբերել պրոցեսը real time է, թե normal։ Միջակայքը 0-139 է։/<br>Real time priority /նախատեսված է real time պրոցեսների համար։ Միջակայքը 1-99/<br><br>Real time պրոցեսների դեպքում կատարվում է այն պրոցեսը, որի առաջնահերթությունը բարձր է։<br>Հաջորդ պրոցեսը կսկսի կատարվել այն ժամանակ, երբ ինչ որ պատճառով terminate լինի։<br>Պլանավորումը կատարվում է SCHEDFIFO և SСHEDERR policy-ներով։ <br>Prioritu-ները քննարկվում են run queue-ի մեջ, որը իրենից ներկայացնում է linked list:<br>Առաջինը այն պրոցեսն է, որի առաջնահերթությունը ամենաբարձրն է։<br>Նույն priority ունեցող պրոցեսները կատարվում են round robin-ով։ Դրա ժամանակը <br>հաշվարկվում է quantum հաստատուն թվով, որը կախված է  պլատֆորմի հնարավորություններից։<br><br>Normal պրոցեսների դեպքում օգտագործվում է CFS scheduler-ը՝ completly fair scheduler:<br>Հստակ ժամանակ է տրվում ամեն պրոցեսին, static priority-ն ինչքան ցածր լինի, այդքան շատ <br>ժամանակ կկատարվի cpu-ի կողմից, ինչքան բարձր լինի, այդքան քիչ։<br>Պլանավորումը կատարվում է SCHED_NORMAL, SCHED_IDLE և SСHED_BARCH policy-ներով։<br>SCHED_BATCH-ի nice value-ն միշտ 19 է, կատարվում է ամենավերջում։<br>SCHED_IDLE-ը priority-ի միտք չունի, կատարվում է ավելի ուշ, քան SCHED_BATCH-ը։<br>Քննարկկվում է nice value /-20...19/, ինչքան բարձ է, այդքան &quot;հաճելի է&quot; և շատ է զիջում։<br><br>Nice value-ից կախված բարձր կամ ցածր է process weight-ը։ /weight = nice value + 20/<br>int nice(int inc); //տալիս է nice value-ն մեծացնելու հնարավորություն։<br>nice(0); //կվերադարձնի պրոցեսի տվյալ պահի նայս վալյուն։<br><br>Պլանավորման համար կա struct sched_entity* se {<br>ulong vrruntime; //virtual runtime, ինչքան ժամանակ պետք է ստանա cpu-ի կողմից։<br>ulong exec_start; //ցույց է տալիս երբ է սկսել պրոցեսը կատարել։<br>ulong now; //ցույց է տալիս տվյալ պահի ժամը<br><br><br>delta_exec = new - exec_start;<br>vruntime += delta_exec;<br><br>virt_delta_exec = delta_exec x (NICE_O_LOAD / load_weight);<br><br><br>int setpriority(int whitch, pid_t who, int prio); //թույլ է տալիս փոխել մեր ցանկացած պրոցեսի <br>nice value-ն<br>which ` <br>PRIO_PROCESS <br>PRIO_GROUP<br>PRIO_USER<br><br>int getpriority(int which, int who); //տալիս է priority-ն<br><br>int sched_setscheduler(pid_t pid, int policy, const struct schedparam_t* params);<br>կարողանալու ենք նշել policy<br><br>int sched_get_priority_max(int policy);<br>int sched_get_priority_min(int policy);<br><br><br><br>int sched_rr_get_interval(pid_t pid, struct timespec* sp);<br><br>struct timespec {<br>  ulong sec;<br>  ulong nanosec;<br>};<br><br>int sched_yield();<br><br>cpu set_t set; //զանգված է․ որըպահում է ինֆորմացիա core-երի մասին<br>void CPU_ZERO(cpu set_t*); //մաքրում է զանգվածը<br>int CPU_ISSET(ulong, cpu set_t); //մեր ուզած core-ը զանգվածում գտնվում է թե ոչ<br>void CPU_CLR(ulong, cpu set_t*); ջնջում է զանգվածից մեր ուզած core-ը<br>void CPU_SET(ulong, spu set_t*); տեղադրում ենք մեր ուզած core-ը բազմության մեջ<br><br>int sched_get_affinity(pid_t pid, int size, cpu set_t* set);<br>//թույլ է տալիս պլանավորումից կախված core-երի միջակայքը ստանալ<br><br>int sched_set_affinity(pid_t pid, int size, const cpu set_t* set);<br><br>core-երի աշխատանքը ճիշտ կազմակերպելու համար 3 անդամ փոփոխական կա<br>task struct-ի մեջ՝<br>int on.cpu; //ցույց է տալիս  տեղադրված է պրոցեսը core-ի scheduler-ի մեջ թե ոչ<br>int cpu; //ցույց է տալիս որ core-ի հերթի մեջ է տեղադրված պրոցեսը<br>long cpu_mask; //ցույց է տալիս որ core-երը կարող են առնչվել պրոցեսի հետ</td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s0" dir="ltr">signal handling functions</td><td class="s0" dir="ltr">void(*signal(int signum, sighandler_t foo))(int);<br>typedef void(*sighandler_t)(int);<br><br>sighandler_t arr[31];<br><br>void sigint(int signum) {<br>   printf(&quot;chlp mlp&quot;);<br>   exit(0);<br>}<br><br>signal(SIGINT, sigint);<br>signal(SIGINT, sigint)(SIGINT); //նախորդ սիգնալի ցուցիչի հետ է աշխատում<br> <br><br><br>typedef void(*handler_t)(int);<br>typedef void(*sa_sigaction_t)(int, struct siginfo_t*, void*);<br><br>SIG_KILL, SIG_STOP-ը չենք կարող handle անել, բլոկ անել կամ անտեսել <br><br>handler_t signal(int signum, handler_t fptr);<br>handler_t fptr` <br>SIG_IGN //ignore signal<br>SIG_DFL //signal default logic<br><br>void foo(int num) {<br>  printf(&quot;chlp mlp&quot;);<br>  printf(&quot;num&quot;, %d);<br>}<br>signal(SIGSGiV, foo);<br>signal(SIGSEGV, SIG_IGN)(4);<br><br><br>int sigaction(int signum, const struct sigaction_t* new, struct sigaction_t* old);<br>//system call, որի միջոցով կարող ենք handler սահմանել և տեղեկություններ <br>փոխանցել։<br><br>struct sigaction_t {<br>   handler_t handler;<br>   sa_sigaction_t sa_mask;<br>   int flags;<br>   ...<br>}ob;<br><br>flags`<br>SA_RESTART //syscall-ը պետք է կատարվի  handling-ից հետո<br>SA_NOCLDSTOP //child-ի սիգնալը անտեսվելու է<br>SA_SIGINFO //թույլ է տալիս ընտրել handler ֆունկցիան<br>SA_STACK //ազդում ենք context switch-ւ վրա, կապված է փոփոխականները<br>պահելու տեղի հետ։<br> </td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s0" dir="ltr">exeption</td><td class="s0" dir="ltr">Թարգմանաբար հատուկ դեպք։<br>exeption-ները նկարագրելու համար կա table, որտեղ նշվում է exeption-ը բնութագրող <br>համարը և ֆունկցիայի ցուցիչը։<br>Կա exeption table base register:<br><br>exeption-ի առաջացման պատճառ կարող է դառնալ՝<br>1․interrupt  //hardware, ֆիզիկական սարքը, asinchronous exeption<br>2.trap //software, ինստրուկցիաների պատճառով՝ օրինակ syscall ինստրուկցիան,<br>synchronous<br>3.fault //current instruction or termination<br>4.abort //termination<br> </td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s0" dir="ltr">Առաջին 4-ը նախատեսված են սիգնալ ուղարկելու, ստանալու և<br>այլնի համար։ syscall-եր են։<br><br>Հաջորդ 5-ը նախատեսված են userspace-ում սիգնալների set<br>ձևավորելու համար։ ֆունկցիաներ են։<br><br>Վերջինը syscall է</td><td class="s0" dir="ltr">uint alarm(uint seconds); //մեր նշած ժամանակից հետո SIGALARM սիգնալն է գալիս<br>int raise(int signum); //նախատեսված է մեր պրոցեսին կոնկրետ սիգնալ <br>ուղարկելու համար<br>int kill(pid_t pid, int signum); //այլ պրոցեսի ազդանշան ուղարկելու համար է<br>int pause(); //ստոփ է գցում այնքան ժամանակ, քանի դեռ որևէ ազդանշան չի հասել <br><br>int sigemptyset(sigset_t* set); //բազմությունը 0-ացնում է<br>int sigfillset(sigset_t* set); //ավելացնում է բոլոր սիգնալները բազմության մեջ<br>int sigaddset(sigset_t* set, int signum); //թույլ է տալիս ավելացնել սիգնալը set-ին<br>int sigdelset(sigset_t* set, int signum); //ջնջում է կոնկրետ սիգնալ set-ից<br>int sigismember(sigset_t* set, int signum); սիգնալը պատկանում է set-ին, թե ոչ<br><br>int sigpromask(int now, const sigset_t* new, sigset_t* old); //նախատեսված է <br>պրոցեսի բլոկավորվող սիգնալ սեթը ձևափոխելու համար;<br>now` <br>SIG_BLOCK<br>SIG_UNBLOCK<br>SIG_SETMASK<br> </td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s0" dir="ltr">Information node</td><td class="s0" dir="ltr">ֆայլին բնութագրող հատկություններ, մետաինֆորմացիաա, որը հետաքրքիր է<br>միայն օպերացիոն համակարգին։ Ներկայացված է ֆայլի անունը, չափը,<br>permission-ների ցանկը ․․․։ Դիրեկտորիաները իրենցից ներկայացնում են <br>information node-երի հավաքածու։<br>  </td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s0" dir="ltr">PCB, file descriptor</td><td class="s0" dir="ltr">PCB-ի մեջ կա files_struct* files, որի միջոցով օպերացիոն համակարգը գտնելու է<br>ֆայլային համակարգի համար անհրաժեշտ ամբող ինֆորմացիան։ Սրա մեջ կա<br>strcut fdtable* fd_t, որը ֆայլային դեսկրիպտորների աղյուսակ է։ Սրա մեջ է գտնվում<br>struct file* file-ը, որտեղ պահվում է ինֆորմացիա, թե որ ֆայլի հետ ինչ աշխատանք<br>է կատարվում, պահում է position-ի մասին ինֆորմացիա։<br> </td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s0" dir="ltr">int open(const char* pathname, int flags);<br>int open(const char* pathname, int flags, mode_t permissions);<br><br>int creat(const char* pathname, mode_t permissions);</td><td class="s0" dir="ltr">Վարիատիկ ֆունկցիա է, բայց 3 արգումենտից ավել փոխանցելը իմաստ չունի՝<br>կամ կանտեսվի, կամ խնդիր կառաջացնի։<br><br>flags`<br>O_RDONLY //միայն կարդալ<br>O_WRONLY //միայն գրել<br>O_RDWR //կարդալ և գրել<br>O_APPEND //ավելացվում է վերջից<br>O_ASYNC //օգտագործվում է socket-ների, messegeq-երի, pipe-երի հետ։<br>Socket-ի մեջ ինֆորմացիա գրելու դեպքում հայտվում է SIGIO ազդանշանը։<br>O_CLOEXEC //հիշողության տեսքը փոխելու դեպքում կփակվեն տվյալ ֆլագով<br>ֆայլերը<br>O_CREAT //Եթե չկա ֆայլ այդ փաթնեյմով, կստեղծվի, եթե լինի ուղղակի կբացի<br>O_EXCL //Եթե արդեն ստեղծված լինի ֆայլը, error կտա O_CREAT-ի հետ<br>O_DIRECT //անմիջապես HDD-ի հետ է կատարվելու աշխատանքը, բլոկի չափով է<br>կարդում գրում /512 բայթ/<br>O_DIRECTORY //եթե pathname-ը դիրեկտորիայի վրա չի տանում, error կտա<br>O_LARGEFILE //մեծ ֆայլերի հետ աշխատելու համար է, position-ը քննարկվում է <br>long_long-ով<br>O_NOCTTY //կապված է demon պրոցեսների հետ<br>O_NOFOLLOW //symbolic link-ի դեպքում error կտա<br>O_NOFOLLOWANY //ամբողջ pathname-ում մեկ սիմվոլիկ լինք լինի, error կտա<br>O_NONBLOCK //character file-երի հետ աշխատելիս է օգտագործվում<br>O_TRUNC //իմաստ չկա կիրառել O_APPEND-ի հետ, ֆայլը 0-ացվում է, սկսում է <br>գրել կարդալ ֆայլի սկզբից<br>O_SYNC //ցանկացած փոփոխություն տվյալների մակարդակով սինխրոնիզացվում է<br> </td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s0" dir="ltr">ssize_t read(int fd, void* buf, size_t bytes);<br><br>RIO - robust input output, ավելի անվտանգ read<br> </td><td class="s0" dir="ltr">Թույլ է տալիս արդեն բացված ֆայլի պարունակությունը կարդալ:<br>Վերդարձնելու է թե քանի բայթ է կարդացել<br> <br>Position-ը կարդացած բայթերի քանակով փոխվելու է։<br> </td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s0" dir="ltr">EOF = -1 //end of file<br> </td><td class="s0" dir="ltr">Հաջորդ read-ը կվերդարձնի 0</td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s0" dir="ltr">ssize_t write(int fd, const void* buf, size_t bytes);</td><td class="s0" dir="ltr">EOF չի քննարկվում, ինչքան գրենք կտեղադրվի բուֆերի մեջ<br> </td></tr><tr style="height: 20px"><th id="0R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s0" dir="ltr">int fsync(int fd);<br>int fdatasync(int fd);<br>void sync();</td><td class="s0" dir="ltr">Բուֆերիզացման համար նախատեսված ֆունկցիաներ են։<br>fdatasync-ը միայն բուֆերի պարունակությունը սինխրոնիզացնելու համար է։<br>fsync-ը բացի բուֆերի տվյալներից թարմացնում է նաև մետաինֆորմացիան։<br>sync-ը միշտ կատարվում է, սինխրոնիզացնում է բոլոր ֆայլային դեսկրիպտորնեով։<br> </td></tr><tr style="height: 20px"><th id="0R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s0" dir="ltr">int close(int fd);</td><td class="s0" dir="ltr">Փակում ենք ֆայլը, չսինխրոնիզացված ինֆորմացիան սինխրոնիզացվում է<br> </td></tr><tr style="height: 20px"><th id="0R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s0" dir="ltr">Positions</td><td class="s0" dir="ltr">off_t //position-ը քննարկող տիպը<br><br>off_t lseek(int fd, off_t pos, int source_position); //positon-ը փոխելու համար է,<br>վերադարձնում է փոփխությունից հետո position-ը։ Չկատարվելու դեպքում <br>վերադարձնում է -1։<br><br>int source_position`<br>SEEK_CUR //current position += pos;<br>SEEK_END //current position = file end position + pos;<br>SEEK_SET //current position = pos;<br> </td></tr><tr style="height: 20px"><th id="0R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s0" dir="ltr">ssize_t pread(int fd, void* bif, size_t count, off_t position);</td><td class="s0" dir="ltr">current position-ից անկախ է դիրքը, նշում ենք position-ով։<br> </td></tr><tr style="height: 20px"><th id="0R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s0" dir="ltr">int truncate(const char* parhname, off_t len);<br>int ftruncate(int fd, off_t len);<br> </td><td class="s0" dir="ltr">Կարողանալու ենք ֆայլի չափը փոխել։ <br>Truncate-ի դեպքում pathname-ի միջողով,<br>Ftruncate-ի դեպքում fd-ի միջողով։<br>Position-ի փոփոխություն տեղի չի ունենում, վերադարձնում է կամ -1 կամ 0։ <br> </td></tr><tr style="height: 20px"><th id="0R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s0" dir="ltr">int select(int maxfd, fd_set* rdfds, fd_set* wrfds, fd_set* <br>except_fds, struct timeval* timeout);<br> </td><td class="s0" dir="ltr">multiplexing i/o-ի համար է նախատեսված։<br><br>fd_set - unsigned long //քննարկվում է 4 մակրոս՝<br>FD_CLR(int fd, fd_set* set); //նշված սեթից մաքրում է մեջ նշած fd-ն<br>FD_ISSET(int fd, fd_set* set); //արդյոք տվյալ fd-ն գտնվում է տվյալ set-ում<br>FD_SET(int fd, fd_Set* set); //fd-ն ավելացնում է սեթի մեջ<br>FD_ZERO(fd _set* set); //մաքրում է սեթը<br><br>struct timeval {<br>  uint second;<br>  uint microseconds;<br>};<br> </td></tr><tr style="height: 20px"><th id="0R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s0" dir="ltr">multiplexing i/o</td><td class="s0" dir="ltr">Եթե առնչվում ենք շատ ֆայլերի հետ,դրանց մեջից առանձնացնում ենք այն ֆայլերը,<br>որոնց հետ հնարավոր է աշխատել։<br> </td></tr><tr style="height: 20px"><th id="0R38" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">39</div></th><td class="s0" dir="ltr">OOB data /out of band data/</td><td class="s0" dir="ltr">Հատուկ տվյալներ, որոնք կարևոր են<br> </td></tr><tr style="height: 20px"><th id="0R39" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">40</div></th><td class="s0" dir="ltr">int pselect (int maxfd, fd_set* rdfd, fd_set* wrfd, fd_set* exfd, <br>const struct timespec_t* timeout, const sigset_t* sigmask);<br><br>int poll(struct pollfd* fds, nfds_t nfds, int timeout);</td><td class="s0" dir="ltr">ժամանակը քննարկոիմ է նանովայրկյաններով։<br><br>2-ի նպատակն էլ այն է, որ հասկանանք որ ֆալը որ գործողությունները թույլ կտա <br>կատարել։ Տարբեր է կազմակերպման ձևը։<br>int timeout-ը քննարկում է ժամանակը միլիվայրկյաններով։<br><br>struct pollfd {<br>  int fd;<br>  short events;<br>  short revents;<br>};<br><br>events` <br>POLLIN // ֆայլի մեջից պրոցեսին ցանկացած բնույթի ինֆորմացիաա տալու միտքը<br>POLLRDNORM //ֆայլի մեջից կարող ենք կարդալ նորմալ ինֆորմացիա<br>POLLRDBAND //character file-երից պրոցեսը կարող է կարդալ OOB data<br>POLLPRI //պրոցեսը կարող է ֆայլից կարդալ OOB data<br>POLLOUT //նորմալ ինֆորմացիա կարող ենք գրել ֆայլի մեջ<br>POLLWRNORM //նորմալ ինֆորմացիա կարող ենք գրել ֆայլի մեջ<br>POLLWRBANK //OOB ինֆորմացիա պրոցեսից դեպի ֆայլ<br>POLLMSG //կարող ենք իմանալ եթե տվյալ fd-ի մեջ բան գրվի կիմանանք թե ոչ<br>POLLERR //revents-ի մեջ եթե լինի error կառաջանա<br>POLLHUP //revents-ի մեջ եթե գրված լինի ուրեմն socket-ի մյուս կողմը ակտիվ չէ<br>POLLINVAL<br></td></tr><tr style="height: 20px"><th id="0R40" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">41</div></th><td class="s0" dir="ltr">int stat(const char* pathname, struct stat* obj);<br>int fstat(int fd, struct stat* obj);<br>int lstat(const char* pathname, struct stat* obj);</td><td class="s0" dir="ltr">stat_ը նայելու է pathname-ի մերջում նշված symbolic link-ին, <br>fstat-ը այն ֆայլին,որի վրա հղված է սիմվոլիկ լինքը։<br><br>struct stat {<br>  dev_t st_dev; //կիրառվում է character, block ֆայլերի համար, սարքային աշխատանք<br>  ino_t st_inode; //տվյալ ֆայլի inode-ի արժեքը<br>  mode_t st_mode; //permissions octal<br>  nlink_t st_nlink; //hard links count<br>  uid_t st_uid; //owner user id<br>  gid_t st_gid; //file group id<br>  dev_t st_rdev; //type<br>  timespec access_time; //վերջին անգամ երբ ենք հասանելիություն ստացել<br>  timespec modif_time; //վերջին անգամ երբ ենք փոփոխություն արել<br>  timespec meta_change_time;<br>  off_t size; //տվյալների չափը<br>  uint blk_size; //բլոկի չափը<br>  uint blocks; //բլոկների քանակությունը<br>}  <br> </td></tr><tr style="height: 20px"><th id="0R41" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">42</div></th><td class="s0" dir="ltr">buffered input/output<br> </td><td class="s0" dir="ltr">FILE data type - union</td></tr><tr style="height: 20px"><th id="0R42" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">43</div></th><td class="s0" dir="ltr">FILE* fopen(const char* pathname, char* mode);<br> </td><td class="s0" dir="ltr">char* mode`<br>r<br>r+<br>w<br>w+<br>a<br>a+<br> </td></tr><tr style="height: 20px"><th id="0R43" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">44</div></th><td class="s0" dir="ltr">FILE* fdopen(int fd, char* mode);<br> </td><td class="s0"></td></tr><tr style="height: 20px"><th id="0R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s0" dir="ltr">int fclose(FILE* fp);<br> </td><td class="s0"></td></tr><tr style="height: 20px"><th id="0R45" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">46</div></th><td class="s0" dir="ltr">void setbuf(FILE* fp, char* buf);<br> </td><td class="s0" dir="ltr">Առանց չափ նշելու buffer ենք ստեղծում;</td></tr><tr style="height: 20px"><th id="0R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s0" dir="ltr">int setvbuf(FILE* fp, char* buf, int mode, size_t size);<br> </td><td class="s0" dir="ltr">Այստեղ նշելու ենք նաև բուֆերի չափը։<br><br>int mode`<br>_IOFBF //input output full buffer file, sinchronization if buffer full<br>_IOLBF //input output line buffer file, sinchronization every line<br>_IONBF //input output no buffer file, npt sinchonize<br> </td></tr><tr style="height: 20px"><th id="0R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s0" dir="ltr">size_t fread(void* ptr, size_t size, size_t count, FILE* fp);<br> </td><td class="s1" dir="ltr">The return value of fread is the number of elements successfully read. If an error <br>occurs or the end of the file is reached before reading the specified number of <br>elements, fread will return a value less than count.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    char buffer[100];<br><br>    // Open a file in binary read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;rb&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Read 10 elements of size 10 from the file into buffer<br>    size_t elements_read = fread(buffer, 10, 10, fp);<br>    if (elements_read != 10) {<br>        perror(&quot;Error reading from file&quot;);<br>        fclose(fp);<br>        return -1;<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    // Process the data read from the file<br>    // ...<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R48" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">49</div></th><td class="s0" dir="ltr">size_t fwrite(consy void* ptr, size_t size, size_t count, FILE* fp);<br> </td><td class="s1" dir="ltr">The return value of fwrite is the number of elements successfully written to the file. <br>If an error occurs, fwrite will return a value less than count.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    int data[] = {1, 2, 3, 4, 5};<br><br>    // Open a file in binary write mode<br>    fp = fopen(&quot;example.bin&quot;, &quot;wb&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Write 5 elements from the data array to the file<br>    size_t elements_written = fwrite(data, sizeof(int), 5, fp);<br>    if (elements_written != 5) {<br>        perror(&quot;Error writing to file&quot;);<br>        fclose(fp);<br>        return -1;<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R49" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">50</div></th><td class="s0" dir="ltr">int fgetc(FILE* fp);<br></td><td class="s1" dir="ltr">The return value of fgetc is the character read as an unsigned char cast to an int <br>or EOF (End of File) to indicate an error or the end of the file.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    int c;<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Read characters from the file until end of file<br>    while ((c = fgetc(fp)) != EOF) {<br>        printf(&quot;%c&quot;, c);<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R50" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">51</div></th><td class="s0" dir="ltr">int fputc(int character, FILE* fp);<br> </td><td class="s1" dir="ltr">The return value of fputc is the character written as an unsigned char cast to an int, <br>or EOF to indicate an error.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    int c;<br><br>    // Open a file in write mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;w&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Write characters to the file<br>    for (c = &#39;a&#39;; c &lt;= &#39;z&#39;; ++c) {<br>        if (fputc(c, fp) == EOF) {<br>            perror(&quot;Error writing to file&quot;);<br>            fclose(fp);<br>            return -1;<br>        }<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R51" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">52</div></th><td class="s0" dir="ltr">int fgets(char* str, int size, FILE* fp);<br> </td><td class="s1" dir="ltr">The return value of fgets is str if successful, or NULL if an error occurs or if the <br>end of the file is reached before any characters are read.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    char line[100];<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Read a line from the file<br>    if (fgets(line, sizeof(line), fp) != NULL) {<br>        printf(&quot;Line read: %s&quot;, line);<br>    } else {<br>        perror(&quot;Error reading from file&quot;);<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R52" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">53</div></th><td class="s0" dir="ltr">int fputs(const char* str, FILE* fp);<br> </td><td class="s1" dir="ltr">The return value of fputs is a non-negative integer if successful, or <br>EOF if an error occurs.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    const char *str = &quot;Hello, World!\n&quot;;<br><br>    // Open a file in write mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;w&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Write the string to the file<br>    if (fputs(str, fp) == EOF) {<br>        perror(&quot;Error writing to file&quot;);<br>        fclose(fp);<br>        return -1;<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R53" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">54</div></th><td class="s0" dir="ltr">int fprintf(FILE* fp, const char* format,...);<br> </td><td class="s1" dir="ltr">The return value of fprintf is the number of characters written if successful, or a <br>negative value if an error occurs.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    int num1 = 10;<br>    double num2 = 3.14;<br><br>    // Open a file in write mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;w&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Write formatted output to the file<br>    if (fprintf(fp, &quot;Integer: %d, Double: %f\n&quot;, num1, num2) &lt; 0) {<br>        perror(&quot;Error writing to file&quot;);<br>        fclose(fp);<br>        return -1;<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R54" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">55</div></th><td class="s0" dir="ltr">int fileno(FILE* fp);<br> </td><td class="s1" dir="ltr">The return value of fileno is the file descriptor associated with the given <br>FILE object if successful, or -1 if an error occurs.<br><br>#include &lt;stdio.h&gt;<br>#include &lt;unistd.h&gt; // For fileno<br><br>int main() {<br>    FILE *fp;<br>    int fd;<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Get the file descriptor associated with the FILE object<br>    fd = fileno(fp);<br>    if (fd == -1) {<br>        perror(&quot;Error getting file descriptor&quot;);<br>        fclose(fp);<br>        return -1;<br>    }<br><br>    // Perform operations using the file descriptor (e.g., read, write)<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R55" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">56</div></th><td class="s0" dir="ltr">int fscanf(FILE* fp, const char*, ...);<br> </td><td class="s1" dir="ltr">The return value of fscanf is the number of input items successfully matched and <br>assigned. If an error occurs or the end of the file is reached before any data is read, <br>EOF is returned.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    int num1;<br>    float num2;<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Read formatted data from the file<br>    if (fscanf(fp, &quot;%d %f&quot;, &amp;num1, &amp;num2) == 2) {<br>        printf(&quot;Integer: %d, Float: %.2f\n&quot;, num1, num2);<br>    } else {<br>        perror(&quot;Error reading from file&quot;);<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R56" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">57</div></th><td class="s0" dir="ltr">long ftell(FILE* fp);<br></td><td class="s1" dir="ltr">The return value of ftell is the current file position indicator of the specified stream <br>as a long integer. If an error occurs, ftell returns -1L.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    long position;<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Get the current file position<br>    position = ftell(fp);<br>    if (position == -1L) {<br>        perror(&quot;Error getting file position&quot;);<br>        fclose(fp);<br>        return -1;<br>    }<br><br>    printf(&quot;Current position: %ld\n&quot;, position);<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R57" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">58</div></th><td class="s0" dir="ltr">int fseek(FILE* fp, long off, int source_position);<br></td><td class="s0" dir="ltr">source_position: This parameter specifies the reference position from where the <br>offset is applied. It can take one of the following values:<br><br>SEEK_SET (0): The offset is relative to the beginning of the file.<br>SEEK_CUR (1): The offset is relative to the current file position.<br>SEEK_END (2): The offset is relative to the end of the file.<br>The return value of fseek is 0 if successful, and non-zero if an error occurs.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    int ch;<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Move the file position indicator to the end of the file<br>    if (fseek(fp, 0, SEEK_END) != 0) {<br>        perror(&quot;Error seeking file&quot;);<br>        fclose(fp);<br>        return -1;<br>    }<br><br>    // Get the current file position<br>    long position = ftell(fp);<br>    if (position == -1L) {<br>        perror(&quot;Error getting file position&quot;);<br>        fclose(fp);<br>        return -1;<br>    }<br><br>    printf(&quot;Current position: %ld\n&quot;, position);<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R58" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">59</div></th><td class="s0" dir="ltr">void rewind(FILE* fp);<br></td><td class="s1" dir="ltr">The rewind function in C is used to reset the file position indicator to the beginning of <br>the file associated with the given stream. It&#39;s equivalent to calling <br>fseek(fp, 0, SEEK_SET).<br><br>The rewind function doesn&#39;t return any value.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br>    int ch;<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Reset the file position indicator to the beginning of the file<br>    rewind(fp);<br><br>    // Read and print characters from the file<br>    while ((ch = fgetc(fp)) != EOF) {<br>        putchar(ch);<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R59" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">60</div></th><td class="s0" dir="ltr">int ferror(FILE* fp);<br></td><td class="s1" dir="ltr">The return value of ferror is non-zero if an error indicator is set for the stream, <br>indicating that an error has occurred during a previous operation on that stream. <br>Otherwise, it returns zero.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Perform operations on the file<br>    // For demonstration, let&#39;s attempt to read a character from the file<br>    int ch = fgetc(fp);<br>    if (ch == EOF) {<br>        if (ferror(fp)) {<br>            perror(&quot;Error reading from file&quot;);<br>        } else {<br>            printf(&quot;End of file reached.\n&quot;);<br>        }<br>    } else {<br>        printf(&quot;Read character: %c\n&quot;, ch);<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R60" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">61</div></th><td class="s0" dir="ltr">void clearerr(FILE* fp);<br> </td><td class="s1" dir="ltr">The clearerr function in C is used to clear the end-of-file and error indicators for a <br>given stream.<br>The clearerr function doesn&#39;t return any value.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Attempt to perform operations on the file<br>    // For demonstration, let&#39;s attempt to read a character from the file<br>    int ch = fgetc(fp);<br>    if (ch == EOF) {<br>        if (ferror(fp)) {<br>            perror(&quot;Error reading from file&quot;);<br>        } else {<br>            printf(&quot;End of file reached.\n&quot;);<br>        }<br><br>        // Clear the error and end-of-file indicators<br>        clearerr(fp);<br>    } else {<br>        printf(&quot;Read character: %c\n&quot;, ch);<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R61" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">62</div></th><td class="s0" dir="ltr">int feof(FILE* fp);<br> </td><td class="s0" dir="ltr">The feof function in C is used to check whether the end-of-file indicator has been set <br>for a given stream.<br><br>The return value of feof is non-zero if the end-of-file indicator is set for the stream, <br>indicating that the end of the file has been reached during a previous operation on<br> that stream. Otherwise, it returns zero.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br><br>    // Open a file in read mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;r&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Perform operations on the file<br>    // For demonstration, let&#39;s attempt to read characters from the file until EOF is reached<br>    int ch;<br>    while ((ch = fgetc(fp)) != EOF) {<br>        putchar(ch);<br>    }<br><br>    // Check if EOF indicator is set<br>    if (feof(fp)) {<br>        printf(&quot;\nEnd of file reached.\n&quot;);<br>    } else {<br>        printf(&quot;\nEOF indicator not set.\n&quot;);<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R62" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">63</div></th><td class="s0" dir="ltr">int fflush(FILE* fp);<br> </td><td class="s1" dir="ltr">By calling fflush on a file stream, you explicitly instruct the system to write any <br>buffered data associated with that stream to the file immediately. This ensures that<br> the file is updated with the most recent data you&#39;ve written to it.<br><br>The return value of fflush is 0 if successful. If an error occurs or if the given stream <br>is not an output or update stream, fflush returns EOF and sets the error indicator <br>for the stream.<br><br>#include &lt;stdio.h&gt;<br><br>int main() {<br>    FILE *fp;<br><br>    // Open a file in write mode<br>    fp = fopen(&quot;example.txt&quot;, &quot;w&quot;);<br>    if (fp == NULL) {<br>        perror(&quot;Error opening file&quot;);<br>        return -1;<br>    }<br><br>    // Write some data to the file<br>    fprintf(fp, &quot;Hello, World!\n&quot;);<br><br>    // Flush the output buffer to ensure data is written to the file<br>    if (fflush(fp) != 0) {<br>        perror(&quot;Error flushing output buffer&quot;);<br>        fclose(fp);<br>        return -1;<br>    }<br><br>    // Close the file<br>    fclose(fp);<br><br>    return 0;<br>}<br></td></tr><tr style="height: 20px"><th id="0R63" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">64</div></th><td class="s0" dir="ltr">size_t readv(int fd, const struct iovec* vec, int count);<br><br>size_t writev(int fd, const struct iovec* vec, int count);</td><td class="s0" dir="ltr">struct iovec {<br>  void* iov_base;<br>  size_t iov_len;<br>};<br> </td></tr><tr style="height: 20px"><th id="0R64" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">65</div></th><td class="s0" dir="ltr">int epoll_create1(int flag);</td><td class="s0" dir="ltr">Վերադարձնում է ֆայլային դեսկրիպտոր, հակառակ դեպքում՝ -1<br><br>flag` <br>EPOLL_CLOEXEC<br> </td></tr><tr style="height: 20px"><th id="0R65" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">66</div></th><td class="s0" dir="ltr">int epoll_ctl(int epfd, int operation, int fd, struct epoll_event* <br>event);</td><td class="s0" dir="ltr">struct epoll_event{<br>  u32 events;<br>  union for_user {<br>    void* ptr;<br>    int fd;<br>    u32 data1;<br>    u64 data1<br>  } data;<br>};<br> <br>events`<br>EPOLLERR. //սահմանում է օպերացիոն համաակարգը;<br>EPOLLHUP  //փակ սոքեթի դեպքն է ցույց տալու;<br>EPOLLIN //write կարող ենք անել թե ոչ<br>EPOLLOUT //Ցանկացած տեսակի ինֆորմացիա<br>EPOLLPRI //Քննարկում է միայն priroity ունեցող տվյալները<br>EPOLLONESHOT //Իվենթը մեկ անգամ ենք քննարկելու<br>EPOLLET //edge trigger, ֆայլի վիճակի փոփոխութան դեպքում է <br>ակտիվանում<br><br>operations`<br>EPOLL_CTL_ADD<br>EPOLL_CTL_MOD<br>EPOLL_CTL_DEL<br> </td></tr><tr style="height: 20px"><th id="0R66" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">67</div></th><td class="s0" dir="ltr">int epoll_wait(int epfd, struct epoll_event* events, int maxevents,<br>int timeout);<br> </td><td class="s0" dir="ltr">timeout - miliseconds</td></tr><tr style="height: 20px"><th id="0R67" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">68</div></th><td class="s0" dir="ltr">int munmap(void* ptr, size_t old_size);<br> </td><td class="s0" dir="ltr">unmap է անում</td></tr><tr style="height: 20px"><th id="0R68" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">69</div></th><td class="s0" dir="ltr">void* mremap(void* ptr, size_t old_size, size_t n_size,<br>ulong flag);<br> </td><td class="s0" dir="ltr">աշխատում է realloc ֆունկցիայի նման.<br>flags`<br>0 //նախնական page-ի դիրքը փոփոխման ենթակա չի<br>MREMAP_MAYMOVE //թույլ է տալիս փոխել page-ի դիրքը<br> </td></tr><tr style="height: 20px"><th id="0R69" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">70</div></th><td class="s0" dir="ltr">նit mprotect(const void* ptr, size_t len, int prot);</td><td class="s0" dir="ltr">prot`<br>PROT_READ<br>PROT_WRITE<br>PROT_EXEC<br>PROT_NONE<br> </td></tr><tr style="height: 20px"><th id="0R70" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">71</div></th><td class="s0" dir="ltr">Iint msync(void* ptr, size_t len, int flags);</td><td class="s0" dir="ltr">true or false<br>original ֆայլի հետ է սինխրոնիզացնում.<br><br>flags`<br>MS_SYNC //քանի դեռ լրիվ չի սինխրոնիզացվել hdd-ի մեջ, չի ավարտվի<br>MS_ASYNC //ուղղակի պլանավորում է, որ ինչ որ պահի սինխրոնիզացնի<br>MS_INVALIDATE<br> </td></tr><tr style="height: 20px"><th id="0R71" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">72</div></th><td class="s0" dir="ltr">int madvise(void* addr, size_t len, int advice);<br> </td><td class="s0" dir="ltr">advices`<br>MADV_NORMAL //normal optimizations<br>MADV_RANDOM //for many pages, readahead չի անում<br>MADV_SEQUENTIAL //առաջ ընկկնելով հաջորդաբար կարդում է<br>MADV_WILLNEED //հաջորդիվ պետք է գալու<br>MADV_DONTNEED //եթե արդեն փակել ենք էջեր և պետք չեն<br>MADV_DONTFORK //ժառանդ պրոցեսը հուշումները չի ժառանգում<br>MADV_DOFORK<br> </td></tr><tr style="height: 20px"><th id="0R72" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">73</div></th><td class="s0" dir="ltr">int posix_fadvise(int fd, off_t offset, off_t len, int advice);<br></td><td class="s0" dir="ltr">advices`<br>POSIX_FADV_NORMAL<br>POSIX_FADV_RANDOM<br>POSIX_FADV_SEQUENTIAL<br>POSIX_FADV_WILLNEED<br>POSIX_FADV_DONTNEED<br>POSIX_FADV_NOREUSE<br></td></tr><tr style="height: 20px"><th id="0R73" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">74</div></th><td class="s0" dir="ltr">Threads</td><td class="s0" dir="ltr">ունի սեփական stack, օգտվում է ծնող thread-ի վիրտուալ հիշողությունից.<br>Thread-ը ինստրուկցիաների կատարման հոսք է.<br>thread identifier - pid_t tid<br>first thread -  main thread<br><br><br><br>int clone(int(*fn)(void*), void* child_st, int flags, void* args, ...);<br><br>void* args - foundamental data type address;<br>void* child_st - child stack address<br>կարող է ստանալ 3 հավելյալ պարամետր, վերադարձնում է pid:<br>5 - pid_t* ptid;<br>6 - pid_t* ctid;<br>7 - void* new_tls //thread local storage<br><br>flag-ների միջոցով ցույց ենք տալու ինչերը պետք է պատճենվեն.<br>flags`<br>CLONE_VM //վիրտուալ հիշողությունը պետք է նույնը լինի<br>CLONE_THREAD //thread ստեղծելու իմաստը, առանձին sack է քննարկվում<br>CLONE_FS //հիմնականում պրոցեսների հետ է կիրառվում, նույն ֆայլային<br>համակարգից են օգտվելու<br>CLONE_FILES //բոլոր բացված ֆալերի տվյալներն է ստանալու child-ը<br>CLONE_SIGHAND //signal handler-ներն է ժառանգում<br><br>4 հավելյալ flag`<br>CLONE_CHILD_CLEARTID //6 արգումենտ, պրոցեսի ավարտվելուց հետո <br>child pid-ն կամ thread id-ն կտանի կկորցնի.<br>CLONE_CHILD_SETPID //6 Արգումենտ, արժեքավորելու միտքն է<br>CLONE_PARENT_SETPID //5 արգումենտ<br>CLONE_SETTLS //7 արգումենտ, thread local storage- ը նոր էության համար<br>հասանելի է լինելու.<br><br>cp-ppid == pp-pid;<br>pp-pid != cp-pid;<br>pp-pgid == cp-pgid == pp-pid;<br>pp-tgid != cp-tgid;<br>pp-pid == t-pid == pp-tid;<br>pp-ppid == t-ppid;<br>pp-tgid == t-tgid == pp-tid;<br>t-tid = ?;<br></td></tr><tr style="height: 20px"><th id="0R74" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">75</div></th><td class="s0" dir="ltr">posix data types <br>բոլորը հանդիսանում են opaque - անթափանց</td><td class="s0" dir="ltr">pthread_t - thread-ի նույնականացուցիչ, մեծ հիշողություն է ներկայացնում;<br>mutex_t - lock է անում մնացած thread-ները<br>mutex_attr_t - նախատեսված է պայմանը կամ mutex-ը մշակելու համար<br>pthread_cond_t<br>pthread_cond_attr_t<br>pthread_attr_t<br><br>//mutex - mutual exclusion<br> </td></tr><tr style="height: 20px"><th id="0R75" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">76</div></th><td class="s0" dir="ltr">int pthread_creat(pthread_t* thread, const pthread_attr_t* attr, <br>void* (*fptr)(void*), void* args);<br></td><td class="s0" dir="ltr">2-րդ պարամետրին կարելի է փոխանցել NULL</td></tr><tr style="height: 20px"><th id="0R76" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">77</div></th><td class="s0" dir="ltr">int pthread_join(pthread_t tid, void** retval);<br></td><td class="s0" dir="ltr">աշխատում է wait-ի նման<br>միշտ նշելու ենք կոնկրետ tid<br> </td></tr><tr style="height: 20px"><th id="0R77" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">78</div></th><td class="s0" dir="ltr">int pthread_detach(pthread_t tid);<br></td><td class="s0" dir="ltr">այդ պահից սկսած thread-ը պրոցեսից դուրս կհամարվի, վերջանալուն պես կփակվի</td></tr><tr style="height: 20px"><th id="0R78" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">79</div></th><td class="s0" dir="ltr">pthread_t pthread_self();<br></td><td class="s0" dir="ltr">տրամադրում է tid</td></tr><tr style="height: 20px"><th id="0R79" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">80</div></th><td class="s0" dir="ltr">int pthread_equal(pthread_t tid1, pthread_t tid2);<br></td><td class="s0" dir="ltr">համեմատում է 2 տարբեր thread id, տալիս է true or false</td></tr><tr style="height: 20px"><th id="0R80" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">81</div></th><td class="s0" dir="ltr">void pthread_exit(void* retval);<br></td><td class="s0" dir="ltr">The pthread_exit function in C is used to terminate the calling thread and return <br>a value to any waiting threads that join it.<br></td></tr><tr style="height: 20px"><th id="0R81" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">82</div></th><td class="s0" dir="ltr">Պրոցեսների միջև կոմունիկացնիաների հիմմնական ձևերը՝<br><br>communication - տվյալների կամ ինֆորմացիայի տեղափոխում<br>signal - պրոցեսների միջև կապ ստեղխելու պարզագուն միջոց<br>sinchronization<br> </td><td class="s0" dir="ltr">signlas` <br>standart signal //OS-ի կողմից քննարկվող սիգնալներ<br>realtime signal //սարքային մակարդակի սիգնալներ<br><br>sinchronizations`<br>semaphore //առանձնացվում են SystemV և POSIX semaphore-ներ ։<br>Տրամադրում են ինֆորմացիայի փոխանակման հատուկ գործիքներ։<br>POSIX-ը բաժանվում է named ու unnamed: Named-ը կոնկրետ messege queue-ի<br>հետ կապ ունեցողն է, unnamed-ը ուղղակի հայտարարված է և հիշողություն է<br>զբաղեցնում։<br>file lock - աշխատանքի ժամանակ սինխրոնիզացիայի միջոցներն են։<br>Ֆայլերի աշխատանքը կարող ենք ղեկավարել fcntl()-ի միջոցով։<br>Բլոկավորումը կատարվումէ flock()-ի միջոցով։<br>mutex (threads)<br>condition variable (threads)<br><br>communication` <br>data transfer //ակնհայտ չենք առնչվում այն հիշողության հետ, որի հետ աշխատանքը<br>կատարվելու է։ Լինոլու է ինչ որ ֆայլ, որի մեջ տեղեկությունը դրվելու է և դրանից<br>վերցնելու ենք։<br>Կան 3 ճյուղեր՝ <br>byte stream //տարածք, որտեղ ինֆորմացիանբայթերով դնելու ենք և հանենք։<br>pseudoterinal<br>message //ինչ ինփորմացիա տեղադրենք, նույն չափով վերցնելու ենք։<br>shared memory //Օգտվելու են ընդհանուր հիշողությունից։<br></td></tr><tr style="height: 20px"><th id="0R82" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">83</div></th><td class="s0" dir="ltr">System V Shared Memory(Allocation)<br><br>int shmget(key_t key, size_t size, int shmflg);</td><td class="s0" dir="ltr">Թույլ է տալիս քննարկել shared memory-ն<br>Վերադարձնում է shmid(shared memory id)<br><br>Flags`<br>IPC_CREAT<br>IPC_EXCL<br>IPC_PRIVATE<br>give a octal permissions<br><br>Function for key_t`<br>key_t ftok(const char* pathname, int proj_id);<br> </td></tr><tr style="height: 20px"><th id="0R83" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">84</div></th><td class="s0" dir="ltr">System V Shared Memory(Attaching)<br><br>void* shmat(int shmid, const void* suggestaddr, int shmflg);</td><td class="s0" dir="ltr">The shmat function is a system call in Unix-like operating systems (such as Linux) <br>used to attach shared memory segments to the address space of a process. This<br> allows multiple processes to share a region of memory, which can be useful for inter-<br>process communication (IPC).<br><br>flags`<br>SHM_RDONLY<br>SHM_RND (Related with SHMLBA (Segment Low Boundry Address);<br>Թույլ է տալիս page-ի սկզբից քննարկել, կլորացնում է հասցեն<br> </td></tr><tr style="height: 20px"><th id="0R84" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">85</div></th><td class="s0" dir="ltr">System V Shared Memory (Controlling)<br><br>int shmctl(int shmid, int cmd, struct shmid_ds* buf);</td><td class="s0" dir="ltr">Commands`<br>IPC_RMID<br>IPC_STAT //shmid_ds struct-ի տվյալները կստանքն<br>IPC_SET<br><br>Structs`<br>struct shmid_ds {<br>  struct ipc_perm shm_perm;<br>  size_t shm_segsz; //չափը<br>  time_t shm_atime;  //last attach time<br>  time_t shm_dtime;  //detach time<br>  time_t shm_ctime;  //creation time<br>  pid_t shm_cpid;  //first<br>  pid_t shm_lpid;  //last<br>  shmatt_t shm_nattch; //NO of attach, detach-ների քանակը չի քննարկվում<br>};<br><br>struct ipc_perm {<br>  key_t key;<br>  uid_t uid;<br>  gid_t gid;<br>  uid_t cuid;<br>  gid_t cgid;<br>  unsigned short mode;<br> ...<br>};<br> </td></tr><tr style="height: 20px"><th id="0R85" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">86</div></th><td class="s0" dir="ltr">POSIX Shared Memory(Creating)<br><br>int shm_open(const char* name, int aflag, mode_t mode);</td><td class="s0" dir="ltr">Flags`<br>O_CREAT<br>O_EXCL<br>O_RDWR<br>O_RDONLY<br>O_WRONLY<br> <br>Name-Ը պետք է սկսվի /-ով<br></td></tr><tr style="height: 20px"><th id="0R86" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">87</div></th><td class="s0" dir="ltr">POSIX shared Memory (Deleting)<br><br>int shm_unlink(const char* name);<br> </td><td class="s0" dir="ltr">Ազատում ենք shared memory-ն</td></tr><tr style="height: 20px"><th id="0R87" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">88</div></th><td class="s0" dir="ltr">POSIX Shared Memory (Working)<br><br><br>void* mmap(void* addr, size_t lenght, int prot, int flags, int fd,<br>off_t offset);<br><br>int munmap(void* addr, size_t lenght);<br><br>int ftruncate(int fd, off_t lenght);<br></td><td class="s0" dir="ltr">եթե write-ի հնարավորություն չունի ֆայլը ftruncate-ը չի կատարվի</td></tr><tr style="height: 20px"><th id="0R88" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">89</div></th><td class="s0" dir="ltr">Thread initialization and destruction`<br><br><br>int pthread_attr_init(pthread_attr_t* attr);<br><br>int pthread_attr_destroy(pthread_attr_t* attr);<br></td><td class="s0" dir="ltr">init-ով default արժեքներն ենք տալիս ատրիբուտների<br>destroy-ով ատրիբուտների զբաղեցրած հիշողությունը ազատում ենք</td></tr><tr style="height: 20px"><th id="0R89" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">90</div></th><td class="s0" dir="ltr">Define Detach state`<br><br><br>Macroses`<br>PTHREAD_CREATE_JOINABLE<br>PTHREAD_CREATE_DETACHED<br><br><br>Prototypes`<br><br>int pthread_attr_getdetachstate(const pthread_attr_t* attr, <br>int* detachstate);<br><br>int pthread_attr_setdetachstate(pthread_attr_t* attr, <br>int detachstate);<br></td><td class="s0" dir="ltr">set, get ֆունկցիաների նպատակը private անդամ փսփոխականներին արժեքավորել կարողանալն է։<br><br>Վերադարձնում է 0 եթե նրմալ է աշխատել, 0-ից տարբերվող արժեք, եթե քնդիր է առաջացել</td></tr><tr style="height: 20px"><th id="0R90" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">91</div></th><td class="s0" dir="ltr">Work with Scheduler(ls inheritable);<br><br><br>Macroses`<br>PTHREAD_INHERIT_SCHED<br>PTHREAD_EXPLICIT_SCHED<br><br><br>Protoyipes`<br><br>int pthread_attr_getinheritsched(const pthread_attr_t* attr,<br>int* inheritsched);<br><br>int pthread_attr_setinheritsched(pthread_attr_t* attr, <br>int inherisched);<br></td><td class="s0" dir="ltr">Ցույց են տալիս, եթե նոր thread ստեղծենք պետք է ժառանգի scheduler-ի տվյալները, թե<br>մենք պետք է սահմանենք՝ INHERIT - կժառանգի, EXPLICIT - կսահմանենք</td></tr><tr style="height: 20px"><th id="0R91" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">92</div></th><td class="s0" dir="ltr">Work with Scheduler(Definition of Priority and Policy)`<br><br><br>struct objects`<br>struct sched_param {<br>  int sched_priority;<br>  ...;<br>};<br><br><br>Macroses(Peer policy Parameter)<br>SCHED_OTHER(SCHED_NORMAL)<br>SCHED_FIFO<br>SCHED_RR<br><br><br>Prototypes`<br><br>int pthread_attr_getschedparam(const pthread_attr_t* attr, <br>struct sched_param* param);<br><br>int pthread_attr_setschedparam(pthread_attr_t* attr, <br>const struct sched_param* param);<br><br>int pthread_attr_getschedpolicy(const pthread_attr_t* attr,<br>int* policy);<br><br>int pthread_attr_setschedpolicy(pthread_attr_t* attr, int policy);<br></td><td class="s0" dir="ltr">pthread_attr_getschedparam: This function retrieves the scheduling parameters <br>(priority and policy) from the specified thread attributes object (attr) and stores them <br>in the sched_param structure pointed to by param.<br><br><br>pthread_attr_setschedparam: This function sets the scheduling parameters (priority <br>and policy) in the specified thread attributes object (attr) according to the values <br>specified in the sched_param structure pointed to by param.<br><br><br>pthread_attr_getschedpolicy: This function retrieves the scheduling policy from the<br>specified thread attributes object (attr) and stores it in the integer pointed to by policy.<br><br><br>pthread_attr_setschedpolicy: This function sets the scheduling policy in the specified<br>thread attributes object (attr) according to the value specified in the integer policy.<br></td></tr><tr style="height: 20px"><th id="0R92" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">93</div></th><td class="s0" dir="ltr">Define Thread Working Scope`<br><br><br>Macroses`<br>PTHREAD_SCOPE_SYSTEM<br>PTHREAD_SCOPE_PROCESS<br><br><br>Prototypes`<br><br>int pthread_attr_getscope(const pthread_attr_t* attr, int* scope);<br><br>int pthread_attr_setscope(pthread_attr_t* attr, int scope);<br></td><td class="s0" dir="ltr">Թույլ են տալիս քննարկել thread-ի ռեսուրսները պրոցեսի շրջանակներում<br><br>SCOPE_SYSTEM //ցանկացած thread համակարգի շրջանակներում հայտնի է լինելու<br>SCOPE_PROCESS //scope-ի , պրոցեսի շրջանակներում է հայտնի լինելու, ոչ<br>բոլոր օպերացիոն համակարգերն են թույլ տալիս։<br><br>get-ով կարող ենք ստանալ, set-ով փոխել</td></tr><tr style="height: 20px"><th id="0R93" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">94</div></th><td class="s0" dir="ltr">Definition of Stack for Thread`<br><br><br>Macroses`<br>PTHREAD_STACK_MIN<br><br><br>Prototypes`<br><br>int pthread_attr_getstack(const pthread_attr_t* atr,<br>void** stackaddr, size_t* stacksize);<br><br>int pthread_attr_setstack(pthread_attr_t* attr, void* stackaddr,<br>size_t stacksize);<br><br>int pthread_attr_getstacksize(const pthread_attr_t* attr, <br>size_t* stacksize);<br><br>int pthread_attr_setstacksize(pthread_attr_t* attr, <br>size_t stacksize);<br><br>int pthread_attr_getstackaddr(const pthread_attr_t* attr, <br>void** stackaddr);<br><br>int pthread_attr_setstackaddr(pthread_attr_t* attr,<br>void* stackaddr);<br></td><td class="s0" dir="ltr">getstack-ը տալիս է getstecksize, getstackaddr ֆունկցիաների միտքը,<br>setstack-ը տալիս է setstecksize, setstackaddr ֆունկցիաների միտքը<br><br>Stackaddr-ին կարող ենք տալ NULL</td></tr><tr style="height: 20px"><th id="0R94" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">95</div></th><td class="s0" dir="ltr">Definition of Guard size of stack`<br><br><br>int pthread_attr_getguardsize(const pthread_attr_t* attr,<br>size_t* guardsize);<br><br>int pthread_attr_setguardsize(pthread_attr_t* attr, <br>size_t guardsize);<br> </td><td class="s0" dir="ltr">stack overflow-ի դեպքում runtime error կառաջանա և պրոցեսը կավարտվի</td></tr><tr style="height: 20px"><th id="0R95" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">96</div></th><td class="s0" dir="ltr">Mutex initialization and Destruction<br><br><br>Macroses(Static initialization)`<br>PTHREAD_MUTEX_INITIALIZER<br>PTHREAD_ERRORCHECK_MUTEX_INITIALIZER<br>PTHREAD_RECURSIVE_MUTEX_INITIALIZER<br><br><br>Prototypes`<br><br>int pthread_mutex_init(pthread_mutex_t* mutex, <br>const pthread_mutexattr_t* attr);<br><br>int pthread_mutex_destroy(pthread_mutex_t* mutex);<br><br></td><td class="s0" dir="ltr">Ռեսուրսից օգտվելու մակարդակով ենք կազմակերպում սինխրոնիզացիան<br><br>mutex - փոխադարձ բացառում<br><br>mutex-ներին հիմնականում քննարկում են գլոբալ տիրույթում։ Լինում են 3 տեսակի (macroses)`<br><br>PTHREAD_MUTEX_INITIALIZER: This macro initializes a mutex object with default <br>attributes. Mutexes initialized with this macro are of the normal type, meaning they <br>do not perform error checking or handle recursive locking.<br><br>PTHREAD_ERRORCHECK_MUTEX_INITIALIZER: This macro initializes a mutex<br>object with error-checking attributes. Mutexes initialized with this macro are error-<br>checking mutexes, which means that attempting to lock a mutex already locked by <br>the calling thread results in an error (returning EDEADLK), rather than deadlock.<br><br>PTHREAD_RECURSIVE_MUTEX_INITIALIZER: This macro initializes a mutex <br>object with attributes supporting recursive locking. Mutexes initialized with this <br>macro are recursive mutexes, meaning that a thread can lock the mutex multiple <br>times (in a nested fashion) without causing a deadlock.<br></td></tr><tr style="height: 20px"><th id="0R96" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">97</div></th><td class="s0" dir="ltr">Working with mutexes(locking and unlocking)`<br><br><br>int pthread_mutex_lock(pthread_mutex_t* mutex); <br>//maybe EDEADLOCK<br><br>int pthread_mutex_rtylock(pthread_mutex_t* mutex); //EBUSY<br><br>int pthread_mutex_timelock(pthread_mutex_t* mutex,<br>const struct timespec* abstime); //ETIMEDOUT<br><br>int pthread_mutex_unlock(pthread_mutex_t* mutex);<br> </td><td class="s0" dir="ltr">trylock-ը բաց mutex-ը կփակի, փակի դեպքում error կտա</td></tr><tr style="height: 20px"><th id="0R97" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">98</div></th><td class="s0" dir="ltr">pthread_mutexattr_t initialization and deruction<br><br><br>int pthread_muexattr_init(pthread_mutexattr_t* attr);<br><br>int pthread_mutex_destroy(pthread_mutexattr_t* attr);<br></td><td class="s0"></td></tr><tr style="height: 20px"><th id="0R98" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">99</div></th><td class="s0" dir="ltr">Work with pthread_mutexattr_t(mutex tyoes)<br><br><br>Macroses`<br>PTHREAD_MUTEX_NORMAL(PTHREAD_MUTEX_DEFAULT)<br>PTHREAD_MUTEX_RECURSIVE<br>PTHREAD_MUTEX_ERRORCHECK<br><br><br>Prototypes`<br><br>int pthread_mutexattr_settype(pthread_mutexattr_t* attr, <br>int type);<br><br>int pthread_mutexattr_gettype(const pthread_mutexattr_t* attr,<br>int* type);<br></td><td class="s0" dir="ltr">PTHREAD_MUTEX_NORMAL (PTHREAD_MUTEX_DEFAULT): This macro<br> represents the default mutex type. Mutexes of this type do not perform error <br>checking and are not recursive. If you initialize a mutex attribute without explicitly<br> setting the type, it will default to this type.<br><br>PTHREAD_MUTEX_RECURSIVE: This macro defines a mutex type that supports<br> recursive locking. Recursive mutexes allow the same thread to lock the mutex<br> multiple times without causing deadlock.<br><br>PTHREAD_MUTEX_ERRORCHECK: This macro defines a mutex type that <br>performs error checking. Error-checking mutexes detect errors such as attempting <br>to lock a mutex already locked by the same thread and return an error code<br> (EDEADLK) instead of causing undefined behavior.</td></tr><tr style="height: 20px"><th id="0R99" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">100</div></th><td class="s0" dir="ltr">Work with pthread_mutexattr_t(mutex Robustness)<br><br><br>Macroses`<br>PTHREAD_MUTEX_STALLED<br>PTHREAD_MUTEX_ROBUST<br><br><br>prototypes`<br><br>int pthread_mutexattr_setrobust(pthread_mutexattr_t* attr,<br>int robust);<br><br>int pthread_mutexattr_getrobust(const pthread_mutexattr_t* attr,<br>int* robust);<br> </td><td class="s0" dir="ltr">lock անելիս robust-ի դեպքում նշվելու է տեղեկություն thread-ի մասին, որ եթե հանկարծ<br>thread-ը վերանա, unlock արվի<br><br>stalled-ը նորամալ դեպքն է</td></tr><tr style="height: 20px"><th id="0R100" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">101</div></th><td class="s0 softmerge" dir="ltr"><div class="softmerge-inner" style="width:381px;left:-1px">work with pthread_mutexattr_t(mutex shareability)<br><br><br>Macroses`<br>PTHREAD_PROCESS_PRIVATE<br>PTHREAD_PROCESS_SHARED<br><br><br>Prototypes`<br><br>int pthread_mutexattr_setpshared(pthread_mutexattr_t* attr,<br>int pshared);<br><br>int pthread_mutexattr_getpshared(const pthread_mutexattr_t* attr,<br>int* pshared);<br></div></td><td class="s0" dir="ltr">թույլ է տաալիս ուրիշ պրոցեսներն էլ օգտնվեն thread-ից</td></tr><tr style="height: 20px"><th id="0R101" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">102</div></th><td class="s0" dir="ltr">Cond(Condition) initialization and destruction<br><br><br>Macroses`<br>PTHREAD_COND_INITIALIZER<br><br><br>prototypes`<br><br>int pthread_cond_init(pthread_cond_t* cond, const <br>pthread_condattr_t* attr);<br><br>int pthread_cond_destroy(pthread_cond_t* cond);<br><br></td><td class="s0" dir="ltr">pthread_cond_init: This function initializes the condition variable pointed to by cond.<br> You can optionally pass attributes (attr) to specify the behavior of the condition <br>variable. If attr is NULL, default attributes are used. This function must be called <br>before the condition variable is used in other pthread condition functions.<br><br><br>pthread_cond_destroy: This function destroys the condition variable pointed to by <br>cond, releasing any resources associated with it. After calling <br>pthread_cond_destroy(), the condition variable should not be used until it is <br>reinitialized using pthread_cond_init().</td></tr><tr style="height: 20px"><th id="0R102" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">103</div></th><td class="s0" dir="ltr">Working with conds(waiting and signaling)<br><br>int pthread_cond_wait(pthread_cont_t* cond,<br>pthread_mutex_t* mutex);<br><br>int pthread_cond_timedwait(pthread_cond_t* resstrict cond,<br>pthread_mutex_t* mutex, const struct timespec* abstime);<br><br>int pthread_cond_signal(pthread_cond_t* cond);<br><br>int pthread_cond_broadcast(pthread_cond_t* cond);<br> </td><td class="s0" dir="ltr">pthread_cond_wait: This function atomically unlocks the mutex pointed to by mutex<br> and waits on the condition variable pointed to by cond. The mutex must be locked by<br> the calling thread before calling pthread_cond_wait(). The thread will remain blocked<br> until another thread signals the condition variable and the thread is awakened. Upon<br> waking up, the mutex will be locked again by the thread.<br><br>pthread_cond_timedwait: This function is similar to pthread_cond_wait, but it allows<br> the calling thread to specify a maximum time to wait for the condition variable to be<br> signaled. The argument abstime specifies an absolute timeout in the form of a <br>timespec structure. If the condition variable is signaled before the timeout expires, <br>the function returns 0. If the timeout expires before the condition variable is <br>signaled, the function returns ETIMEDOUT.<br><br>pthread_cond_signal: This function wakes up one thread that is waiting on the<br> condition variable pointed to by cond, if there are any waiting threads. If no threads<br> are waiting, the function has no effect.<br><br>pthread_cond_broadcast: This function wakes up all threads that are waiting on the<br> condition variable pointed to by cond. It essentially signals all waiting threads, <br>allowing them to proceed.<br></td></tr><tr style="height: 20px"><th id="0R103" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">104</div></th><td class="s0" dir="ltr">reinbrant </td><td class="s0" dir="ltr">գլոբալ փոփոխականներից չօգտվող, խորհուրդ է տրվում threadn-ները կազմակերպել այսպես<br><br>Ֆունկցիաները ցանկալի է մշակել թե thread_local storage class-ի տարբերակվով, թե <br>սպեցիֆիկ տարբերակով։<br>Որպեսզի ունենանք thread-ին սպեցիֆին ինֆորմացիա, պետք է ունենակ key:<br> </td></tr><tr style="height: 20px"><th id="0R104" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">105</div></th><td class="s0" dir="ltr">pthread_once_t initialization and usinig<br><br>static initializes`<br>PTHREAD_ONCE_INIT<br><br>prototype`<br>int pthread_once(pthread_once_t* once_object,<br>void (*init_finction)(void));<br> </td><td class="s0" dir="ltr">այս օբյեկտը կարողանում է վերահսկել, որ փոխանցված ֆունկցիան կատարվի մեկ անգամ։</td></tr><tr style="height: 20px"><th id="0R105" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">106</div></th><td class="s0" dir="ltr">pthread_key_t creation  and deleting<br><br><br>prototypes`<br><br>int pthread_key_create(pthread_key_t* key, <br>detructor_t dstr_fptr);<br><br>int pthread_key_delete(pthread_key_t key);<br><br><br>typedefs`<br>typedef void(*desctructor_t)(void*);<br> </td><td class="s0" dir="ltr">destructor-ը տալիդ կսրող ենք չմտածել free-ի մասին</td></tr><tr style="height: 20px"><th id="0R106" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">107</div></th><td class="s0" dir="ltr">pthread_key_t work with key specified value<br><br><br>int pthread_setspecific(pthread_key_t key, const void* value);<br><br>void* pthread_getspecific(pthread_key_t key);<br> </td><td class="s0" dir="ltr">սկզբում անում ենք getspecific-ը, եթե վերադարձնի NULL, malloc ենք անում, հետո setspecific</td></tr><tr style="height: 20px"><th id="0R107" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">108</div></th><td class="s0" dir="ltr">thread cancellation<br><br>int pthread_cancel(pthread_t thread);<br> <br><br>Macroses`<br>PTHREAD_CANCEL_DISABLE<br>PTHREAD_CANCEL_ENABLE<br> </td><td class="s0" dir="ltr">կանչելու ենք այն թրեդի մեջից, որի միջոցով ուզում ենք անջատել թրեդը<br><br><br>Կարող է ընդունել թ վիճակ, կամ ուզում է անջատել, կամ չի ուզում</td></tr><tr style="height: 20px"><th id="0R108" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">109</div></th><td class="s0" dir="ltr">cancellation types<br><br>int pthread_setcanceltype(int type, int* oldtype);<br><br>Macroses`<br>PTHREAD_CANCEL_DEFERRED<br>PTHREAD_CANCEL_ASYNCHRONOUS<br></td><td class="s0" dir="ltr">Իմաստ ունի անել միայն enable cancel state-ով thread-ների համար</td></tr><tr style="height: 20px"><th id="0R109" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">110</div></th><td class="s0" dir="ltr">explicit cancellation point<br><br>void pthread_taskcancel();<br></td><td class="s0" dir="ltr">Եթե thread-ը cancel signal է ստացել, կավարտվի տեղում, թե չի ստացել չւ ավարտվի<br><br>kill signal-ի իմիտացիա է անում</td></tr><tr style="height: 20px"><th id="0R110" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">111</div></th><td class="s0" dir="ltr">cleanup handler<br><br><br>prototypes`<br><br>void pthread_cleanup_push(cleanup_handler_t cleanup_fptr,<br>void* arg);<br><br>void pthread_cleanup_pop(int execute);<br><br><br>Typedef`<br>typdef viod(*cleanup_handler_t)(void*);<br> </td><td class="s0" dir="ltr">cleanup handler-ը ածխատում է միայն եթե cancel է արվել։<br><br>Եթե execute-ին փոխանցենք 0, function stack-ի գագաթին ընկած ֆունկցիային վերացնում ենք։</td></tr><tr style="height: 20px"><th id="0R111" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">112</div></th><td class="s0" dir="ltr">sending signals<br><br><br>prototypes`<br><br>int pthread_kill(pthread_t thread, int sig);<br><br>int pthread_sigqueue(pthread_t thread, int sig, <br>const union sigval value);<br><br><br>complex data type`<br><br>union sigval {<br>  int sival_int;<br>  void* sival_ptr;<br>};<br><br></td><td class="s0" dir="ltr">pthread_kill-ի միջոցով սովորական signal handler-ի ազդանշանն ենք ուղարկում<br><br>pthread_sugqueue-ի միջոցով signal handler-ին կարող ենք փոխանցել նաև արժեք</td></tr><tr style="height: 20px"><th id="0R112" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">113</div></th><td class="s2 softmerge" dir="ltr"><div class="softmerge-inner" style="width:915px;left:-1px">blocking signals<br><br>prototypes`<br>int pthread_sigmask(int how, const sigset_t* set, sigset_t* oldset);<br><br><br><br>function prototypes for working signal set`<br><br><br>int sigemtyset(sigset_t* set);<br><br>int sigfillset(sigset_t* set);<br><br>int sigaddset(sigset_t* set. int signo);<br><br>int sigdelset(sigset_t* set, int signo);<br><br>int sigismember(const sigset_t* set, int signo);<br> <br><br><br>Macroses`<br>SIG_BLOCK<br>SIG_UNBLOCK<br>SIG_SETMASK<br></div></td><td class="s3"></td></tr><tr style="height: 20px"><th id="0R113" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">114</div></th><td class="s0" dir="ltr">waiting signals`<br><br>int sigwait(const sigset_t* set, int* sig);<br> </td><td class="s0" dir="ltr">Հենց բազմության մեջից ինչ որ սիգնալ հասնի պրոցեսին, thread-ը կվերսկսի իր աշխատանքը։<br>sig-ի մեջ գցելու է այն սիգնալը, որից հետո վերսկսել է աշխատանքը։</td></tr></tbody></table></div>