<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s0{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:402px;" class="column-headers-background">A</th><th id="0C1" style="width:517px;" class="column-headers-background">B</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" dir="ltr">Pipe and FIFO</td><td class="s0" dir="ltr">FIFO - Named Pipe<br><br>Pipe- Ստեղծվում է պրոցեսի շրջանակներում, երբ բոլոր պրոցեսները pipe-ի <br>հետ կապը կորցնեն, pipe-ը կորչելու է։<br>FIFO-ն արտահայտվում է ֆայլային համակարգի մեջ։ Ունենալու է իր<br>information node-ը HDD-ում, բայց data-ի բաժին չի ունենալու։<br><br>Pipe-ի հետ աշխատելը վերաբերում է ինչ որ սպեցիֆիկ պրոցեսների։<br>Կիրառվում է արյունակցական կապ ունեցող պրոցեսնի հետ։<br>FIFO-ի դեպքում ցանկացած 2 պրոցես իմանալով FIFO-ի pathname-ը՝<br>կարող են բացել և աշխատել։<br><br>2-ն էլ հանդիսանում են stream-եր, positional աշխատանք չենք կարող<br>կատարել։<br><br>Pipe-ը իրենից ներկայացնում է սովորական խողովակ։ 2-ի դեպքում էլ <br>խողովակի մի եզրից կարողանալու ենք գրել, մյուս եզրից կարողանալու ենք<br>կարդալ։ Ունենալու ենք 2 file descriptor` read-ի համար, write-ի համար։<br>Ցանկալի է որ գրել կարդալու եզրերը պատկանեն տարբեր պրոցեսների։<br><br>Եթե pipe-ը դատարկ լինի, read syscall-ը բլոկավորվում է։ <br>Եթե write-ի կողմից աշխատող պրոցեսներ կամ file descriptor-ներ կան,<br>դա հանդիսանում է բլոկի պատճառ։ Եթե write-ի կողմից ուղղակի փակ <br>լինի, կարդացող պրոցեսը ստանալու է EOF-ի միտքը՝ 0։<br><br>Write-ի բլոկավորման պատճառները շատ են։ Դրանցից մեկը կապված է<br>OS-ի տրամադրած հիշողության հետ։ OS-ը քննարկում է առանձին pipe-ի<br>հիշողության չափ և տվյալների կտորների հիշողության չափ։<br>Pipe-ի մեջ մտնող ինֆորմացիայի չափը կարող ենք ստանալ PIPE_BUF <br>մակրոսի միջոցով։ Լինուքսի հին վերսիաների կողմից դա կազմում է 512<br>բայթ, հիմա արդեն 4096 է։ Ինֆորմացիան ցանկալի է փոխանցել <br>PIPE_BUF-ի չափով, որպեսզի OS-ը իր կողմից կտորների չբաժանի։<br></td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s0" dir="ltr">Creating Pipe<br><br>int pipe(int pipefd[2]);<br>pipefd[0] - read<br>pipefd[1] - write<br><br>int pipe2(int pipefd[2], int flags);<br>flags`<br>O_CLOEXEC<br>O_NONBLOCK<br>O_DIRECT<br> </td><td class="s0" dir="ltr">Pipe stexcelu hamar anhrajesht e stexcel 2 fd-ic baxkacac zangvac, vori mej pipe <br>syscall-ic heto kpahvi mer read-i ev write-ihamapatasxan fd-nere:<br><br>pipe2-y hnaravorutyun e talis faylayin descriptor-i path-i vra haveljal flag-ner <br>sahmanenq<br><br>O_DIRECT` swaping space-i het kap uni</td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s0" dir="ltr">Duplication of File Descriptors<br><br>int dup(int oldfd);<br>int dup2(int oldfd, int newfd);<br>int dup3(int oldfd, int newfd, int flags);<br><br>flags`<br>O_CLOEXEC<br></td><td class="s0" dir="ltr">Redirection kazmakerpelu hamar anhrajesht e katarel duplicateing:<br><br>Dup-in talu enq 1 fd, vore petq e duplicate lini: FD Table-i ayd toxe duplicate e<br>linum urish index-ov toxi vra: Duplicate-ic araj ev heto anhrajeshtt e duplicacvox<br>fd-n pakel, duplikacvac fd-n pakel:<br><br>close(STDIN_FILENO);<br>dup(pipefd[0]);<br>close(pipefd[0]);<br><br>dup2-y tuyl e talis arajin close-ic xusapel:<br><br>dup2(pipefd[o], STDIN_FILENO);<br>close(pipefd[0]);<br><br>dup3-i depqum duplikacvac fd-n exec-i ardyunqum pakvelu e:<br></td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s0" dir="ltr">Pipes With Terminal<br><br>FILE *popen(const char *command, const char *type);<br>int pclose(FILE *stream);<br><br>Type`<br>&quot;w&quot;<br>&quot;r&quot;<br></td><td class="s0" dir="ltr">popen-in talu enq mer uzac hramane, verjum nshelu enq hramany ogtagorcenq<br>vorpes stdin,   te stdout: veradarcnum e FILE tipi hxum, vori mijocov karox enq <br>hramanneri tvac patasxannere stanal, kam hramanin arjeq poxancel:</td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s0" dir="ltr">Making FIFO Files<br><br>Command`<br>mkfifo -m 660 chlp<br><br>int mkfifo(const char *pathname, mode_t mode);<br></td><td class="s0" dir="ltr">FIFO-n faylayin hamakrgum goyutyun unecox eutyun e, dra hamar petq e nax stexcel,<br>heto ashaxtel FIFO-ov: Mode-y talis enq chmod-i permissionneri pes:<br><br>FIFO-n uni butagrox tar` P(pipe):<br><br>FIFO read only bacelu depqum blokavorvelu e aynqan jamanak, qani der write-i <br>hamar chi bacvel:, nuyne hakarakn el e chisht:<br><br>open-i jamanak O_RDWR petq che tal, xndir karajana file-i hxumy pahelu het:<br>kareli e kirarel O_NONBLOCK mode-y: Write-i het chenq karox ogtagorcel <br>O_NONBLOCK-y:<br></td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s0" dir="ltr">General Introduction to Network</td><td class="s0" dir="ltr">Cancayin ashxatanqi himnakan xndiry platform-neri mijev anhamapatasxanutyunn e:<br><br>Cancayin ashxatanqe nkaragrelu hamar ka hatuk   model` OSI.<br>1. Physical (Physical Device Working Protocols)<br>2. Data Link (ARP(Address Resolution Protocol)) (Creation of Frames)<br>3. Network(IP)(Creation of Packets)<br>4. Transport(TCP/UDP)<br>5. Session<br>6. Presentation (SSL/TLS(Secure sockets Layer/Transport Layer security))<br>7. Application (HTTP- hyper text transfer protocol)<br><br>TCP- Trancmision control protocol`<br>OS-y misht spaselu e patasxani, vor stacel e data-n:<br><br>UDP-User Datagram Protocol`<br>informacian uxarkvum e miakoxmani, patasxani chenq spasum:<br>uxarkum en Datagram-ner` tvjalneri ktorner:<br><br>NIC - Network interface card, ֆիզիկական սարք է, որը ունի դրայվերներ։<br>Ցանկացած սարք, որը ունի NIC, ունի նաև MAC address, որը չի<br>կրկնվում։<br><br>Տվյալ փուլի հետ կապված էությունները՝<br>1․ Physical ( NIC)<br>2․ Data Link (NIC Driver)<br>3․ Network (OS)<br>4․ Transport (OS)<br>5․ Session (OS or Some Process)<br>6․ Presentation (Some Libraries)<br>7․ Application (Process)<br> <br>TCP/IP Model`<br>1.Network Access (data Link, Physical)<br>2. Internet (Network)<br>3. Host-to-Host (Transport)<br>4. Process/Application (Application, Presentation, Session)<br><br>IP հասացեների համար քննարկվում են կոնկրետ range-եր<br>IPv4 Addresses or Address Ranges (Private)`<br>1. Loopback - 127.0.0.1<br>2. 10.0.0.0 - 10.255.255.255 (10.0.0.0/8)<br>3. 172.16.0.0 - 172.31.255.255 (172.16.0.0/12)<br>4. 192.168.0.0 - 192.168.255.55 (192.168.0.0/16)<br><br>CIDR (Classless Inter-Domain Routing)`<br>1. (10.0.0.0/8)<br>2. (172.16.0.0/12)<br>3. (192.168.0.0/8)<br><br>IPS - Internet provider Service - պատասխանատու է ցանցից դուրս <br>ինֆորմացիան տեղափոխելու համար։<br> <br>Domain - սիմվոլների հաջորդականություն է, որին համապատասխանող<br>IP, virtual port կա: Public ip-ն չի կարող կրկնվել։<br><br>DNS հարցում՝ domain name server request, օգտագործվում է domain-ից<br>IP, Port ստանալու համար։<br> </td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s0" dir="ltr">Network Area Types</td><td class="s0" dir="ltr">PAN - Personal Area Network (Bluetooth)<br>LAN - Local Area Network (Enthernet, WI-FI) <br>          WLAN - Wireless Local Area Network(WI-FI)<br>MAN - Metropolitan Area Network (Enthernet MAN)<br>WAN - Wide Area Network (Internet)<br>GAN - Global Area Neetwork (Internet)<br> <br>Ցանկացած ռոուտեր պետք է ապահովի NAT-ի գաղափար`<br>Network Address Translation<br>Private LAN IP Address -&gt; NAT -&gt; Public Internet IP Address<br> </td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s0" dir="ltr">Packet Sending Types </td><td class="s0" dir="ltr">1. Unicast - երբ հստակ գիտենք մյուս կողմի IP-ն, port-ը<br>2. Broadcast ֊ ցանցի շռջանակներում բոլորը, ովքեր կընդունեն, կստանան<br>3. Multicast ֊ ցանցի մեջ ինչ որ առանձնացված խմբի կտռամադրվի<br>4. Anycast ֊ ով կարող է ընդունել ստանում է<br> </td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s0" dir="ltr">Port Numbers</td><td class="s0" dir="ltr">Well Known Ports` 0-1023<br>Registered Ports` 1024 - 49151<br>Dynamic/Private Ports - 49152 - 65535<br> </td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s0" dir="ltr">Sockets`</td><td class="s0" dir="ltr">Ցանցային աշխատանքն ապահովելու համար կիրառվում է <br>սովորական ֆայլ՝ socket: Socket-ն ընդամենը պետք է կցել ցանցին։<br>Socket-ին ճանաչելու համար պետք է քննարկենք, թե իրեն ինչպես ենք<br>հասցելավորելու(address_family), կարող ենք նշել IPv4, iPv6, unix, bluetooth։<br>type - TCP, UDP, ROW: Protocol-ը հիմնականում 0  ենք տալիս։<br><br>int socket(int address_family, int type, int protocol); <br>Վերադարձնում է fd:<br><br>Socket-ին ստեղծելուց հետո անհրաժեշտ է կցել ցանցին bind-ի միջոցով։<br>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>Նշում ենք մեր IP-ն և port-ի համարը։<br><br>int listen(int sockfd, int backlog);<br>Ցույց է տալիս որ սոքեթը պասիվ վիճակում է, ոչ մեկի հետ կապված չէ։<br>backlog-ը ցանցի մեջ սոքեթների քանակությունն է, որը կարելի է կցել։<br><br>Կապի դուրս ենք գալիս accept-ով։<br>int accept(int sockfd, struct sockaddr *addr, socklen_t * addrlen);<br>Նշում ենք այն IP-ն և port-ի համարը, որին ուզում ենք կցվել։<br>Եթե չգիտենք ում ենք ուզում կցվել, նշում ենք address Any:<br>Վեռադարձնում է նոր fd:<br><br>Այն անձը, ով ուզում է կցվել մեզ, պետք է անի connecct<br>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br> </td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s0" dir="ltr">Sendiing and REceiving Data from socket</td><td class="s0" dir="ltr">ssize_t send(int sockfdm const void *buf, size_t len, int flags);<br>Հիշողության պարունակությունը նշված չափով բեռելու են լցնեն<br>սոքեթի մեջ, OS-ն էլ սոքեթի մեջից transport անի, ուղարկի ցանց, <br>ցանցից էլ կգա մյուս սոքեթին արդեն։<br><br>ssize_t recv(int sockfd, void *buf, size_t len, int flags);<br>Սոքեթի մեջից ինֆորմացիան ստանալու համար է։<br><br>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,<br>                        const struct sockaddr *dest_addr, socklen_t addrlen);<br>send-ի լոգիկան է, ուղղակի ամեն անգամ նշաելու ենք հասցեն։<br><br>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,<br>                        struct sockaddr *src_addr, socklen_t *addrlen);<br>recv-ի լոգիկան է, ուղղակի ամեն անգամ նշաելու ենք հասցեն։<br> </td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s0" dir="ltr">Address Conversion Functions</td><td class="s0" dir="ltr">int inet_pton(int addr_faml, const char *src, void *dst);<br>Մեր կողմից քննարկվող IP հասցեն ուզում ենք քննարկել ցանցին <br>հասկանալի տեսքով։<br><br>const char *inet_ntop(int addr_faml, const void *src, char *dst, socklen_t size);<br>2-ական տեսքիզ ձևափոխում է char-երի զանգվածի տեսքի։<br><br>Address Families`<br>AF_INET<br>AF_INET6<br> </td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s0" dir="ltr">get address infromation</td><td class="s0" dir="ltr">int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints,<br>                       struct addrinfo **res);<br>OS-ին տալու ենք թեերի ինֆորմացիա host-ի մասին, <br>համապատասխանող բոլոր տարբերակները կտրամադրվեն մեզ։<br>struct addrinfo **res-ը լիստ է, որի մեջ պահվելու է մեզ տրամադրված<br>ինֆորմացիան։ OS-ը կարող է իրականացնել DNS հարցումներ։<br>service-ին կարող ենք փոխանցել port-ի համար կամ protocol:<br><br>void freeaddrinfo(Struct addrinfo *res);<br>Նախատեսված է մեզ տրամադրված ինֆորմացիան ջնջելու համար։<br><br>struct addrinfo implemetnation`<br>struct addrinfo {<br>   int ai_flags; վերաբերում է getaddrinfo ֆունկցիային<br>   int ai_family; AF_INET, AF_INET6, AF_UNSPEC<br>   int ai_socktype; SOCK_STREAM, SOCK_DGRAM, SOCK_RAW<br>   int ai_protocol; IPPROTO_TCP, IPPROTO_UDP, 0<br>socket type նշելու դեպքում անհրաժեշտություն չկա պրոտոկոլ նշելու։ <br>   socklen_t ai_addrlen; սոքեթի հասցեի չափը<br>   struct sockaddr *ai_addr; հասցեի մասին, port-ի համարի մասին ինֆո<br>   char *ai_canonname; domain-ի մասին է խոսքը<br>   struct addrinfo *ai_next;<br>};<br> <br>Flags`<br>AI_PASSIVE //socket address will be INADDR_ANY or in6addr_any<br>AI_CANONNAME //get ai_canonname<br>AI_NUMERICHOST //node is Port<br>AI_NUMERICSERV //service is Port<br>AI_V4MAPPED //If IPv6 not fount give mapped IPv4 Addr<br>AI_ALL //Give IPv4 and IPv6 Addresses<br> </td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s0" dir="ltr">Socket creation</td><td class="s0" dir="ltr">int socket(int domain, in type, int protocol);<br><br>domain - նախատեսված է հասկանալու համար ինչ ցանցի մեջ է<br>արտահայտվելու`<br>AF_INET<br>AF_INET6<br>AF_UNIX / AF_LOCAL<br>AF_PACKET<br>AF_BLUETOOTH<br><br>type`<br>SOCK_STREAM //TCP, կարելի է ասոցացնել pipe-երի հետ<br>SOCK_DGRAM //UDP, միակողմանի է ինֆորմացիան ուղարկվում<br>SOCK_RAW //transport layer-ը մենք ենք որոշում ինչպես է <br>կազմակերպվելու<br> </td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s0" dir="ltr">Binding the Socket</td><td class="s0" dir="ltr">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br><br>structs`<br>struct sockaddr {<br>   sa_family_t sa_family;<br>   char sa_data[14];<br>}<br><br>type`<br>typedef unsigned int socklen_t<br> </td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s0" dir="ltr">Socket address struct for UNIX address family</td><td class="s0" dir="ltr">struct sockaddr_un {<br>   sa_family_t sun_family; //AF_UNIX<br>   char sun_path[108]; //փոխանցում ենք ֆայլային համակառգի pathname<br>}<br> </td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s0" dir="ltr">Socket address struct for IP4v address family</td><td class="s0" dir="ltr">struct sockaddr_in {<br>   sa_family_t sin_family; //նշելեւ ենք IP4v-ի միտքը՝ AF_INET<br>   in_port_t sin_port; //վիրտուալ պորտի համարը, որի տակ ուզում ենք<br>արտահայտվի սոքեթը, կարող ենք 0 փոխանցել, OS-ը կնշի<br>   struct in_addr sin_addr;  //INADDR_ANY, եթե bind ենք անում INADDR_ANY <br>նշելու դեպքում OS-ը մեր IP-ն է վերցնելու դնի, accept-ի ժամանակ<br>նայում են backlog-ի ժամանակ մեր հետ connect եղած ինչ սեքոթներ<br>կան, դրանցից մեկը դնում են<br>   char sin_zero[8]; //padding-ի հիշողություն է<br>};<br><br>struct in_addr {<br>   uint32_t s_addr;<br>};<br> </td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s0" dir="ltr">Socket address struct for IP6v address family</td><td class="s0" dir="ltr">struct sockaddr_in6 {<br>   sa_family_t sin6_family; //AF_INET6<br>   in_port_t sin6_port; //2 բայթանոց port-ի համարն է, որի byte order-ը <br>պետք է փոխել, նոր տալ<br>   uint32_t sin6_flowinfo; //կարող ենք արժեքավորել 0-ով<br>   struct in6_addr sin6_addr;  //IN6ADDR_ANY<br>   uint32_t sin6_scope_id; //link scope, file scope գաղափարներ կան<br>};<br><br>struct in6_addr {<br>   unsigned char s6_addr[16];<br>};<br> </td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s0" dir="ltr">Listening to Connections (by first host/server)</td><td class="s0" dir="ltr">int listen(int sockfd, int backlog); // Backlog -&gt; BOMAXCONN<br><br>backlog-ով տալիս ենք maximum connection-ների չափը։<br> </td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s0" dir="ltr">accept the connection (by first host/server)</td><td class="s0" dir="ltr">int accept(int sockfd, struct sockaddr *addr, socklen_t* addrlen);<br><br>փոխանցված address-ը պետք է լինի client-ի sockaddress-ը։<br>Ցանկալի է, որ port-ի համարը նույնը լինի։<br>Վերադարձնում է կամ ֆայլային դեսկրիպտոր, կամ -1։<br> </td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s0" dir="ltr">connection with socket (by second host/client)</td><td class="s0" dir="ltr">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br><br>Պետք է նշենք ում ենք connect լինում։<br> </td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s0" dir="ltr">Network Byte Order Conversion</td><td class="s0" dir="ltr">uint16_t htons(uint16-t hostshort); //IPv4, port-ի համարը փոխում է network-ին <br>համապատասխան<br>uint32_t htonl(uint32_t hostlong); //IPv6<br>uint16_t ntohs(uint16_t netshort); //IPv4, network-ի byte order-ից host-ի byte order-ի<br>հասկանալի տեսքի ենք  բերում։<br>uint32_t ntohl(uint32_t netlong); //IPv6<br> </td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s0" dir="ltr">get info by bounded socket</td><td class="s0" dir="ltr">int getpeername(int sockfd, struct sockaddr *addr, socklen_t *adddrlen);<br>accept-ի արդյունքում ստացած socket-ի մասին ենք տեղեկություն <br>դուրս բերում։ Դիմացինի սոքեթի մասին տեղեկություն<br><br>int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<br>Listen անող socket-ի մասին ենք տեղեկություն դուրս բերում։<br>Մեր սոքեթի մասին տեղեկություն<br> </td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s0" dir="ltr">TCP  and UDP</td><td class="s0" dir="ltr">TCP մոտեցմամբ կապ ստեղծելուց հետո կարող ենք արանց սոքեթի <br>մասին ինֆորմացիա նշելու send-ով ուղարկել։ Դա գալիս է նրանից, որ<br>եթե մենք ունենք սոքեթ, որը listen-ի տակ է աշխատում, անընդհատ<br>connection-ներ ընդունելու հնարավորություն կտա մեզ, մենք էլ accept<br>անելուց հետո կստանանք նոր սոքեթի fd, որով էլ կարող ենք<br>ինֆորմացիայի փոխանակությունը կազմակերպել։ Հիմնականում<br>connection-ի ենթարկված socket-ը սկսելու է pipe-ի նման աշխատել։<br>Եթե սոքեթը լիքը լինի, send անելուց բլոկավորվելու ենք, քանի դեռ<br>մյուս կողմից ինֆորմացիան դուրս չեն բերել։ Եթե սոքեթի մեջից<br>փորձենք ինֆորմացիա հանել, բայց դատարկ լինի, էլի բլոկավորվելու<br>ենք։ Կարող  ենք սովորական read writeո֊ով աշխատել։ Եթե <br>մոտեցումը UDP-ի կողմ է գնացել, միշտ ինֆորմացիան ուղարկելիս<br>և ստանալիս պետք է նշենք ում ենք ուղարկում, ումից ենք ստանում։<br>Դրա համար sendto recvfrom syscall-երը քննարկվում են UDP<br>պրոտոկոլից կախված ցանացային աշխատանքի դեպքում։<br>UDP-ի դեպքում է կարելի է connect անել, բայց դա արդեն ավտոմատ<br>նմանվում է TCP-ի։<br> </td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s0" dir="ltr">send() system call</td><td class="s0" dir="ltr">ssize_t send(int sockfd, const void *buf, size_t len, int flags);<br>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, <br>                        const struct sockaddr *dest_addr, socklen_t addrlen);<br><br>Flags`<br>MSG_CONFIRM //UDP, info is received last time (same for sendto), OS-ը <br>սպասում է պատասախանի, ինֆորմացիան հասել է թե ոչ։<br>MSG_DONTROUTE //send info without routting (same for sendto)<br>Նախկինում դուրս բերված ճանապարհով է տանում ինֆորմացիան։<br>MSG_DONTWAIT  //non block working (same for sendto), nonbllock ֆլագին<br>համարժեք աշխատանք է կատարում, սակայն միայն այդ անգամ<br>ինֆորմացիա ուղարկելիս չի բլոկավորվի<br>MSG_MORE //packet is not ended (same for sendto)։ Transport layer-ից այն կողմ<br>էլ ոչինչ տեղի չի ունենում, 2-րդ հոսքը ինֆորմացիան չի տեսնելու<br>MSG_NOSIGNAL //dont sent SIGPIPE (same for sendto)<br>MSG_OOB //send special data (same for sendto): OS-ը յուրահատուկ <br>վերաբերմունք է ցույց տալու<br>MSG_WAITALL //wait until all data will be sended (same for sendto)<br> </td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s0" dir="ltr">recv() system call</td><td class="s0" dir="ltr">ssize_t recv(int sockfd, void *buf, size_t lent, int flags);<br>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, <br>                           const sockaddr *src_addr, socklen_t *addrlen);<br><br>Flags`<br>MSG_DONTWAIT //Non-block , պատկերացնենք read ենք անում առանց<br>բլոկավորվելու<br>MSG_ERRQUEUE //Receive Error messages //ցանցի մեջ առաջացած <br>խնդիրները կարող ենք տեսնել<br>MSG_OOB //receive special data //կարդա;ու է հատուկ տվյալների բուֆերից<br>MSG_PEEK //receive but not clear from stream, ինֆորմացիայի պատճենն ենք<br>ստանում<br>MSG_WAITALL //full info will receive<br>MSG_TRUNC //return size of packet<br> </td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s0" dir="ltr">socket options system calls</td><td class="s0" dir="ltr">int setsockopt(int sockfd, int level, int optame, const void *optval, socklen_t option);<br>int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *option);<br>Սրանց միջոցով հիմնականում ազդեցություն ենք թողնում TCP IP և <br>UDP IP layer-ների վրա։<br><br>Level of Options`<br>SOL_SOCKET<br>IPPROTO_IP<br>IPPROTO_UDP<br>IPPROTO_TCP<br><br>socket-level options (part 1)`<br>SO_BROADCAST //used with 255.255.255.255 IP, պետք է պարտադիր ունենալ<br>UDP socket, ինֆորմացիան կուղարկվի բոլորին<br>SO_DONTROUTE //dont use route information, rout-ը դառնում է մշտական<br>SO_KEEPALIVE //send keep alive messages, կարող է միայն TCP-ի դեպքում<br>օգտագործվել, հատուկ տիպի ինֆորմացիա ենք ուղարկում, որը<br>ժամանակ առ ժամաանակ կուղարկվի host֊ին։ Եթե ինչ որ ժամանակ<br>հետո պատասխան չգա, սոքեթը կանջատվի։<br>SO_LINGER //optval is pօinting to struct linger object , նախատեսված է close<br>system call-ից հետո ինչ որ ժամանակ socket-ը պահելու համար<br>SO_OOBLINE //put it in same socket<br><br>socket-level options (part 2)`<br>SO_RVCBUF //optval is pointing to new receive buffer size memory<br>SO_RCVLOWAT //optval is pointing minimum byte receive notification<br>SO_READFRAG //UNIX specific clear data that not be received<br>SO_REUSEADDR //use socket address in different processes<br>SO_SENDALL //block until all data will be sended<br>SO_SNDBUF //optval is pointing to new send buffer size memory<br>SO_SNDLOWAT //optval is pointing minimum byte send notification<br>SO_USELOOPBACK //sended data can be received<br><br>TCP level options`<br>TCP_NODELAY //send data as soon as possible<br>TCP_MAXSEG //spec. give segment size for second host<br>TCP_KEEPIDLE //set keepalive problems interval when host is just waiting<br>TCP_KEEPINTVL //set interval for next prob<br>TCP_KEEPCNT //set keepalive probes count<br><br>UDP level option`<br>UDP_CHECKSUM //if data corrupted data will be dicarded<br><br>IP level options`<br>IP_TOS //type of service optval can be: IPTOS_LOWDELAY, IPTOS_THROUGHPUT<br>IP_TTL ///when data can be discarded optval can be 1..255 //time to live<br>IP_MULTICAST_IF //set multicast inteface. optval is IPv4 address (struct in_addr)<br>IP_MULTICAST_TTL //times data will be sended optval can be 1 ..255<br>IP_MULTICAST_LOOP // loopback to host<br>IP_ADD_MEMBERSHIP //optval pointing to ip_mreq struct<br>IP_DROP_MEMBERSHIP //optval pointing to ip_mreq struct<br> <br> </td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s0" dir="ltr">get host name information</td><td class="s0" dir="ltr">int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host,<br>                          socklen_t hostlen, char *serv, socklen_t servlen_t servlen, int flags);<br>Կատարում է getaddrinfo-ի հակառակ գործողությունը<br><br>NI_NOFQDN //give only base domain<br>NI_NUMERICHOST //give numeric IP<br>NI_NUMERICSERV //give numeric port<br>NI_DGRAM //give udp hostname<br>NI_NAMEREQD //return error if cant resolve ․եթե տվյալ IP-ով ոչ մի domain<br>չեն գտել, սովորաբար վերադարձվում է մեր նշած IP_ի ձևափոխված<br>տեսքը, այս ֆլագով դրա փոխարեն կվերադարձնի error:<br> </td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s0" dir="ltr">get host info by name</td><td class="s0" dir="ltr">struct hostent *gethostbyname(const char *name);<br>Սպասսում է domain, վերադարձնում է struct-ը;<br>struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);<br>Ստանում է IP address, դրա չափը և family֊ն։<br>2֊ի դեպքում էլ կատարվում են DNS հարցումներ։<br><br>struct hostent {<br>   char *h_name;<br>   char **h_aliases;<br>   int h_addrtype;<br>   int h_lenght;<br>   char **h_addr_list;<br>}<br> </td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s0" dir="ltr">find network interface</td><td class="s0" dir="ltr">int getifaddrs(struct ifaddrs **ifap);<br>վերադարձնում է ifconfig-ի վերադարձրած ինֆորմացիան struct-ի <br>միջոցով։ Ցանցային աշխատանքը քննարկելու համար ցանցի տարբեր<br>interface-ներ են քննարկվում, որոշները ֆիզիկական են, որոշներն էլ<br>վիրտուալ։<br><br>struct ifaddrs {<br>   struct ifaddrs *ifa_next;<br>   char *ifa_name;<br>   unsigned int ifa_flags;<br>   struct sockaddr *ifa_addr; վիրտուալ ինտերֆեյսների դեպքում NULL է<br>   struct sockaddr *ifa_netmask;<br>   ...;<br>};<br><br>Interface names`<br>lo - loopback interface, virtual  interface է<br>gif0 - generic tunnel interface, մեր կողմից նշված IPv4 address-ը ձևափոխում է<br>IPv6 հասցեի և հակառակը<br>eth0, eth1, (en) etc. - ethernel interface, տեսնեելու ենք նաև MAC address-ները<br>wlan0, wlan1 - wireless LAN interface, տեսնեելու ենք նաև MAC address-ները<br>br0, br1 (brigde) - bridge interface, վիրտտուալ ինտերֆեյսներ, նախատեսված<br>մի քանի ինտերֆեյս իրար կապելու համար։<br><br>interface flags - ցույց է տալիս ինչ հնարավորություններ ունենք,<br>ինչ գործողություններ կարելի է տվյալ ինտերֆեյսի վրա քննարկել`<br>IFF_UP //interface is active<br>IFF_BROADCAST //broadcast is available<br>IFF_DEBUG //debug is available<br>IFF_LOOPBACK //it is a loopback interface<br>IFF_POINTOPOINT //it is a PTP interface<br>IFF_NOARP //can not be used ARP recuests<br>IFF_PROMISC //interface receives all packets from network<br>IFF_ALLMULTI //interface receives all multicast packets<br>IFF_MULTICAST //multicast is available<br>IFF_DYNAMIC //dynamic addressing interface<br> </td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s0" dir="ltr">HTTP request types</td><td class="s0" dir="ltr">types`<br>GET //get resource from server<br>HEAD //get header of resource from server<br>POST //send resource to server or change working state of server<br>DELETE //delete resource from server<br>PUT //send resource to server<br>CONNECT //connect with server by proxy server<br>OPTIONS //get types of available requests from server<br>TRACE //loop back request for debugging<br>PATCH //update part of the resource<br><br>Երբ ինչ որ կայք ենք մտնում․ օրինակ գուգլը ինչ որ request է ուղարկում,<br>մեր նշած pathname-ով ինչ որ HTML, CSS կոդ է ստանում, որն էլ ցույց է <br>տալիս  մեզ։ Pathname կամ հղում կոչվածը URL-n է՝ uniform resource locator<br>format (Protocol://(DOmain):port/path to location#hash):<br>Թե response-ի, թե request-ի դեպքում կա header section. request-ից և<br> response-ից կախված կարող է լինել նաև body, որը պարունակելու է <br>սովորական տվյալ։ HTTP-ի դեպքում հիմնականում խոսքը գնում է<br>HTML CSS-ի մասին։<br><br>GET request-ը body չունի։ Սրա միջոցով ուզում ենք ստանալ ինֆորմացիա,<br>նշում ենք path-ը, կարող ենք նշել ինչ որ սպեցիֆիկ դաշտեր, ուղարկում<br>ենք սերվերին, ստանալու ենք response: Միշտ ստանալու ենք body:<br><br>HEAD-ի դեպքում body չենք ստանալու, ստանալու ենք միայն response-ի <br> header-ը, որը բնութագրելու է տվյալ path-ի տակ գտնված ինֆորմացիան<br>ինչ չափի է, ինչ տեսքի է։ Հիմնականում պետք է պատկերացում<br>կազմելու համար։<br><br>POST-ի միջոցով մենք ենք տալիս ինֆորմացիա։ Կարող ենք փոխել <br>սերվերի աշխատանքի լոգիկան։ Լուծում է DELETE, PUT, PATCH <br>խնդիրները։<br><br>DELETE-ը ուղղակի ջնջում է մեր նշած լոկացիայի տակ եղածը։<br>սխալ path-ի դեպքում error է տալիս։<br><br>PUT-ը նոր ռեսուրս է տալիս։<br><br>PATCH-ը update է անում։<br><br>CONNECT-ի դեպքում HTTP-ի սերվերին կցվելուց հետո ասում ենք,<br>որ միջանկյալ proxy server ակտիվ լինի։<br><br>OPTIONS-ի միջոցով սերվերին ասում ենք որ հետ ուղարկի հնարավոր<br>request option-ների ցանկը։<br><br>TRACE- ը իմաստ ունի քննարկել proxy server-ների առկայության <br>դեպքում։ Հետ է ստանում HTTP-ից ոչ միայն response-ը, այլ նաև <br>request-ը։<br> </td></tr><tr style="height: 20px"><th id="0R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s0" dir="ltr">HTTP request header format</td><td class="s0" dir="ltr">Request-ի header-ը ձևաչափ ունի, որը ցանկալի է պահել։<br><br>request line`<br>(Request type)<br>(Path of the resource in server)<br>(HTTP protocol version)<br><br>headers`<br>Host //Domain name of server<br>User-Agent //Client process name<br>Accept-Language //REsponse Language Info<br>Accept //Acceptable response<br>Accept-encoding //Compression type which can be decompressed<br>Connection //Connection type<br>Upgradde-insecure-requests //Update HTTP request to HTTPS //Optional<br>Content-type //Type of data in body<br> </td></tr><tr style="height: 20px"><th id="0R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s0" dir="ltr">HTTP response header format</td><td class="s0" dir="ltr">status-line`<br>(HTTP protocok version)<br>(REquest status code)<br>(Request status text)<br><br>geaders types`<br>general headers //give response general information<br>response heraders //give information about server<br>entity headers //give reponse body information<br>sequrity headers //some security headers provided by protocol implementation<br> </td></tr><tr style="height: 20px"><th id="0R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s0" dir="ltr">status codes of response</td><td class="s0" dir="ltr">1xx. informational<br>100- client must continue their requests<br>101- server switch their protocol by request<br>102- ssrver processing the response<br><br>2xx success<br>200- request is succeeded<br>201- resource is created<br>202- request accepted but not completed<br>203- request is succeeded but content was taken from another service<br>204- server processed request but is not returned content<br><br>3xx redirection`<br>300- multiple choices of resource<br>301- resource currently have new URL<br>302- resource is temoranly located to different URL<br>303- resource is temorarity located to different URL and client must do new GET req.<br><br>4xx client error`<br>400- bad request<br>401- request requires cllient authentication<br>404- resource can not be found<br>414- provided URL is too long<br> <br>5xx seerve error`<br>500- basic error that can be retrieved<br>501- request method not implemented<br>502- proxy server retrieved not valis response from HTTP server<br>503- server currently unaailable<br> </td></tr><tr style="height: 20px"><th id="0R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s0" dir="ltr">query string</td><td class="s0" dir="ltr">?user=bob#<br> </td></tr><tr style="height: 20px"><th id="0R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s0" dir="ltr">SSL/TLS</td><td class="s0" dir="ltr">key layers of protection for TLS(Transport layer security)`<br>Encryption //Encryption of response and request bodys<br>Data integrity //Data cant be modified<br>Authentication //Proves communication between client and server<br><br>key layers of protection for SSI(secure socket layer)`<br>Confidentiality //generate public key for encryption<br>MEssage integrity //Generate private key for message integrity<br><br>TLS/SSL-ի իրար հետ աշխատելու համար իրենց պրոտոկոլները<br>սկզբում պետք է handshake անեն։<br>SSL/TLS handshake steps`<br>1. client hello<br>2. server hello<br>3. server certificate<br>4. server key exchange (optional)<br>5. server hello done<br>6. client key exchange<br>7. client change cipher spec<br>8. client finished messages<br>9. server change cipher spec<br>10. server finished messages<br>  </td></tr></tbody></table></div>